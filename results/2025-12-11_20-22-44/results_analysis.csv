filename,ground_truth_label,model_name,detected_pattern,confidence,adherence,reasoning,raw_response,duration_seconds
DPD-wayback-MementoReplayRendererDecorator.java,decorator,gpt-5,Decorator,98,95,"MementoReplayRendererDecorator extends ReplayRendererDecorator, accepts a ReplayRenderer in its constructor, and augments behavior (sets Memento HTTP headers) before delegating to decorated.renderResource. It preserves the component interface and can be stacked with other decorators. Note: the 'Memento' here refers to the web archiving protocol, not the GoF Memento pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 98,
      ""adherence"": 95,
      ""reason"": ""MementoReplayRendererDecorator extends ReplayRendererDecorator, accepts a ReplayRenderer in its constructor, and augments behavior (sets Memento HTTP headers) before delegating to decorated.renderResource. It preserves the component interface and can be stacked with other decorators. Note: the 'Memento' here refers to the web archiving protocol, not the GoF Memento pattern.""
    }
  ]
}",23.639275
DPD-wayback-MementoReplayRendererDecorator.java,decorator,gemini-3.0-pro,Decorator,100,100,"The class MementoReplayRendererDecorator extends a class named ReplayRendererDecorator and accepts an instance of the component interface (ReplayRenderer) in its constructor. Crucially, inside the 'renderResource' method, it executes custom logic (adding HTTP headers) and then delegates the call to the wrapped object ('decorated.renderResource(...)'). This allows behavior to be added dynamically to the wrapped object, which is the definition of the Decorator pattern. While the class name contains 'Memento', it implements the Memento Web Protocol, not the Memento Design Pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class MementoReplayRendererDecorator extends a class named ReplayRendererDecorator and accepts an instance of the component interface (ReplayRenderer) in its constructor. Crucially, inside the 'renderResource' method, it executes custom logic (adding HTTP headers) and then delegates the call to the wrapped object ('decorated.renderResource(...)'). This allows behavior to be added dynamically to the wrapped object, which is the definition of the Decorator pattern. While the class name contains 'Memento', it implements the Memento Web Protocol, not the Memento Design Pattern.""
	}]
}
```",26.262334
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gpt-5,Decorator,95,90,"The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.""
    },
    {
      ""pattern"": ""Memento"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.""
    }
  ]
}",46.114702
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gpt-5,Memento,85,80,"createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.""
    },
    {
      ""pattern"": ""Memento"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.""
    }
  ]
}",46.114702
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gpt-5,Command,70,65,"Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.""
    },
    {
      ""pattern"": ""Memento"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.""
    }
  ]
}",46.114702
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gpt-5,Observer,65,55,"The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.""
    },
    {
      ""pattern"": ""Memento"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.""
    }
  ]
}",46.114702
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gpt-5,Facade,55,45,"The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class wraps a CoreHelper component (passed via constructor), extends an abstract decorator, and delegates to getComponent().setX methods while adding extra behavior (memento creation). It preserves the original interface and composes the component, matching the Decorator intent.""
    },
    {
      ""pattern"": ""Memento"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""createMemento constructs anonymous ModelMemento objects that capture old/new values and provide undo/redo to restore state without exposing internals. These mementos are handed to a caretaker via Model.notifyMementoCreationObserver, enabling undo history.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each ModelMemento encapsulates a reversible action with redo (execute) and undo (unexecute). The BooleanSetter/ObjectSetter/StringSetter interfaces encapsulate the concrete setter invocation, making each change a command-like object with inverse behavior.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The call Model.notifyMementoCreationObserver(memento) indicates an observable subject notifying observers about memento creation (publisher-subscriber). Registration and observer classes are not shown here, so only partial evidence is present.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The code repeatedly accesses Model.getFacade() to retrieve and interact with model properties through a unified interface, suggesting use of a Facade over a complex subsystem. Only usage is visible in this snippet, not the facade's implementation.""
    }
  ]
}",46.114702
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gemini-3.0-pro,Decorator,100,100,"The class `UndoCoreHelperDecorator` extends `AbstractCoreHelperDecorator` and wraps a `CoreHelper` component (passed in the constructor). It overrides methods (like `setAbstract`, `setName`) to add specific functionality (creating mementos) before delegating the actual operation to the wrapped object via `getComponent().methodName()`. This is the textbook definition of the Decorator pattern.","```json
{
	""design_patterns"": [{
			""pattern"": ""Decorator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class `UndoCoreHelperDecorator` extends `AbstractCoreHelperDecorator` and wraps a `CoreHelper` component (passed in the constructor). It overrides methods (like `setAbstract`, `setName`) to add specific functionality (creating mementos) before delegating the actual operation to the wrapped object via `getComponent().methodName()`. This is the textbook definition of the Decorator pattern.""
		},
		{
			""pattern"": ""Memento"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class contains specific logic to save the state of an object before it is modified. The `createMemento` methods instantiate `ModelMemento` objects that capture the `oldValue` and provide logic to restore the object to that state. This is used to implement the Undo/Redo mechanism.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 90,
			""adherence"": 90,
			""reason"": ""The `ModelMemento` anonymous inner classes implement `undo()` and `redo()` methods, encapsulating the request to modify the model as an object. Additionally, the internal interfaces `BooleanSetter`, `ObjectSetter`, and `StringSetter` are used to encapsulate the specific action of setting a property into an object, effectively parameterizing the method call to be executed later or within the memento.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 80,
			""reason"": ""The method call `Model.notifyMementoCreationObserver(memento)` indicates that the system is notifying registered listeners (subscribers) that a memento has been created. While the registration logic isn't shown here, this class acts as the Publisher/Subject trigger in the Observer pattern.""
		}
	]
}
```",30.06216
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gemini-3.0-pro,Memento,100,100,The class contains specific logic to save the state of an object before it is modified. The `createMemento` methods instantiate `ModelMemento` objects that capture the `oldValue` and provide logic to restore the object to that state. This is used to implement the Undo/Redo mechanism.,"```json
{
	""design_patterns"": [{
			""pattern"": ""Decorator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class `UndoCoreHelperDecorator` extends `AbstractCoreHelperDecorator` and wraps a `CoreHelper` component (passed in the constructor). It overrides methods (like `setAbstract`, `setName`) to add specific functionality (creating mementos) before delegating the actual operation to the wrapped object via `getComponent().methodName()`. This is the textbook definition of the Decorator pattern.""
		},
		{
			""pattern"": ""Memento"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class contains specific logic to save the state of an object before it is modified. The `createMemento` methods instantiate `ModelMemento` objects that capture the `oldValue` and provide logic to restore the object to that state. This is used to implement the Undo/Redo mechanism.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 90,
			""adherence"": 90,
			""reason"": ""The `ModelMemento` anonymous inner classes implement `undo()` and `redo()` methods, encapsulating the request to modify the model as an object. Additionally, the internal interfaces `BooleanSetter`, `ObjectSetter`, and `StringSetter` are used to encapsulate the specific action of setting a property into an object, effectively parameterizing the method call to be executed later or within the memento.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 80,
			""reason"": ""The method call `Model.notifyMementoCreationObserver(memento)` indicates that the system is notifying registered listeners (subscribers) that a memento has been created. While the registration logic isn't shown here, this class acts as the Publisher/Subject trigger in the Observer pattern.""
		}
	]
}
```",30.06216
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gemini-3.0-pro,Command,90,90,"The `ModelMemento` anonymous inner classes implement `undo()` and `redo()` methods, encapsulating the request to modify the model as an object. Additionally, the internal interfaces `BooleanSetter`, `ObjectSetter`, and `StringSetter` are used to encapsulate the specific action of setting a property into an object, effectively parameterizing the method call to be executed later or within the memento.","```json
{
	""design_patterns"": [{
			""pattern"": ""Decorator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class `UndoCoreHelperDecorator` extends `AbstractCoreHelperDecorator` and wraps a `CoreHelper` component (passed in the constructor). It overrides methods (like `setAbstract`, `setName`) to add specific functionality (creating mementos) before delegating the actual operation to the wrapped object via `getComponent().methodName()`. This is the textbook definition of the Decorator pattern.""
		},
		{
			""pattern"": ""Memento"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class contains specific logic to save the state of an object before it is modified. The `createMemento` methods instantiate `ModelMemento` objects that capture the `oldValue` and provide logic to restore the object to that state. This is used to implement the Undo/Redo mechanism.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 90,
			""adherence"": 90,
			""reason"": ""The `ModelMemento` anonymous inner classes implement `undo()` and `redo()` methods, encapsulating the request to modify the model as an object. Additionally, the internal interfaces `BooleanSetter`, `ObjectSetter`, and `StringSetter` are used to encapsulate the specific action of setting a property into an object, effectively parameterizing the method call to be executed later or within the memento.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 80,
			""reason"": ""The method call `Model.notifyMementoCreationObserver(memento)` indicates that the system is notifying registered listeners (subscribers) that a memento has been created. While the registration logic isn't shown here, this class acts as the Publisher/Subject trigger in the Observer pattern.""
		}
	]
}
```",30.06216
PMART-ArgoUML-UndoCoreHelperDecorator.java,decorator,gemini-3.0-pro,Observer,95,80,"The method call `Model.notifyMementoCreationObserver(memento)` indicates that the system is notifying registered listeners (subscribers) that a memento has been created. While the registration logic isn't shown here, this class acts as the Publisher/Subject trigger in the Observer pattern.","```json
{
	""design_patterns"": [{
			""pattern"": ""Decorator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class `UndoCoreHelperDecorator` extends `AbstractCoreHelperDecorator` and wraps a `CoreHelper` component (passed in the constructor). It overrides methods (like `setAbstract`, `setName`) to add specific functionality (creating mementos) before delegating the actual operation to the wrapped object via `getComponent().methodName()`. This is the textbook definition of the Decorator pattern.""
		},
		{
			""pattern"": ""Memento"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class contains specific logic to save the state of an object before it is modified. The `createMemento` methods instantiate `ModelMemento` objects that capture the `oldValue` and provide logic to restore the object to that state. This is used to implement the Undo/Redo mechanism.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 90,
			""adherence"": 90,
			""reason"": ""The `ModelMemento` anonymous inner classes implement `undo()` and `redo()` methods, encapsulating the request to modify the model as an object. Additionally, the internal interfaces `BooleanSetter`, `ObjectSetter`, and `StringSetter` are used to encapsulate the specific action of setting a property into an object, effectively parameterizing the method call to be executed later or within the memento.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 80,
			""reason"": ""The method call `Model.notifyMementoCreationObserver(memento)` indicates that the system is notifying registered listeners (subscribers) that a memento has been created. While the registration logic isn't shown here, this class acts as the Publisher/Subject trigger in the Observer pattern.""
		}
	]
}
```",30.06216
PMART-ArgoUML-UndoUmlHelperDecorator.java,decorator,gpt-5,Decorator,90,80,"UndoUmlHelperDecorator extends AbstractUmlHelperDecorator and accepts a UmlHelper 'component' in its constructor, passing it to the superclass. This matches the Decorator structure: a component interface (UmlHelper), a base decorator (AbstractUmlHelperDecorator) that holds a component, and a concrete decorator (UndoUmlHelperDecorator) that can add behavior. While this class doesn’t override methods in the snippet, the composition and inheritance structure clearly indicate the Decorator pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 90,
      ""adherence"": 80,
      ""reason"": ""UndoUmlHelperDecorator extends AbstractUmlHelperDecorator and accepts a UmlHelper 'component' in its constructor, passing it to the superclass. This matches the Decorator structure: a component interface (UmlHelper), a base decorator (AbstractUmlHelperDecorator) that holds a component, and a concrete decorator (UndoUmlHelperDecorator) that can add behavior. While this class doesn’t override methods in the snippet, the composition and inheritance structure clearly indicate the Decorator pattern.""
    }
  ]
}",21.779353
PMART-ArgoUML-UndoUmlHelperDecorator.java,decorator,gemini-3.0-pro,Decorator,95,100,"The class extends 'AbstractUmlHelperDecorator' (acting as the Base Decorator) and acts as a Concrete Decorator. It accepts an instance of the component interface/abstract class ('UmlHelper') in its constructor and passes it to the superclass. This structural setup allows the object to wrap the component to extend its functionality, matching the definition of the Decorator pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The class extends 'AbstractUmlHelperDecorator' (acting as the Base Decorator) and acts as a Concrete Decorator. It accepts an instance of the component interface/abstract class ('UmlHelper') in its constructor and passes it to the superclass. This structural setup allows the object to wrap the component to extend its functionality, matching the definition of the Decorator pattern.""
	}]
}
```",15.466844
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Factory Method,88,85,"Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Template Method,72,70,"doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Strategy,64,60,"Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Service Locator,58,55,"Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Observer,47,45,"An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gpt-5,Front Controller,50,50,"A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""Creation of StringTemplateViewResolver is delegated to protected createResolver(), allowing subclasses to override the instantiation. The init sequence (createResolver, initParameters, initContexts) uses this factory to supply a configurable product.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 72,
      ""adherence"": 70,
      ""reason"": ""doGet defines the algorithm (resolveTemplate -> render or sendError) with overridable steps via protected hooks (resolveTemplate, viewName, getLocale, pageModel, render). Similarly, createResolver(ServletConfig) fixes the setup steps with hook methods.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 64,
      ""adherence"": 60,
      ""reason"": ""Locale resolution is delegated to a LocaleResolver obtained at runtime, encapsulating the varying algorithm for determining Locale, with a fallback to request.getLocale(). The servlet is agnostic of the concrete strategy.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 58,
      ""adherence"": 55,
      ""reason"": ""Dependencies are retrieved from a global WebApplicationContext (getRequiredWebApplicationContext, wac.getBean), and findTemplateErrorListener encapsulates this lookup before injecting into the resolver.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 47,
      ""adherence"": 45,
      ""reason"": ""An ErrorListener is registered on the resolver (setTemplateErrorListener), suggesting a subject-listener notification relationship; the notification mechanics are not shown in this snippet.""
    },
    {
      ""pattern"": ""Front Controller"",
      ""confidence"": 50,
      ""adherence"": 50,
      ""reason"": ""A single servlet acts as an entry point for its URL mapping, parses the request path, resolves a view, and renders the response, centralizing request handling for a set of requests.""
    }
  ]
}",48.988092
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gemini-3.0-pro,Factory Method,95,100,"The class implements the Factory Method pattern via the protected method 'createResolver()'. This method isolates the instantiation of the 'StringTemplateViewResolver'. By making this method protected and virtual, the class allows potential subclasses to override this specific method to return a subtype of 'StringTemplateViewResolver' (or a configured instance) without needing to rewrite the logic in 'createResolver(ServletConfig)' or 'init'.","```json
{
	""design_patterns"": [{
			""pattern"": ""Factory Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the Factory Method pattern via the protected method 'createResolver()'. This method isolates the instantiation of the 'StringTemplateViewResolver'. By making this method protected and virtual, the class allows potential subclasses to override this specific method to return a subtype of 'StringTemplateViewResolver' (or a configured instance) without needing to rewrite the logic in 'createResolver(ServletConfig)' or 'init'.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The method 'createResolver(ServletConfig)' functions as a Template Method. It defines the skeleton of the algorithm for setting up the view resolver by enforcing a specific sequence of steps: instantiation ('createResolver()'), parameter binding ('initParameters'), and context setup ('initContexts'). These steps are broken out into distinct protected methods, allowing subclasses to redefine specific steps of the initialization process without changing the overarching algorithm structure.""
		}
	]
}
```",31.987184
DPD-spring-stringtemplate-StringTemplateDecoratorServlet.java,decorator,gemini-3.0-pro,Template Method,90,95,"The method 'createResolver(ServletConfig)' functions as a Template Method. It defines the skeleton of the algorithm for setting up the view resolver by enforcing a specific sequence of steps: instantiation ('createResolver()'), parameter binding ('initParameters'), and context setup ('initContexts'). These steps are broken out into distinct protected methods, allowing subclasses to redefine specific steps of the initialization process without changing the overarching algorithm structure.","```json
{
	""design_patterns"": [{
			""pattern"": ""Factory Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the Factory Method pattern via the protected method 'createResolver()'. This method isolates the instantiation of the 'StringTemplateViewResolver'. By making this method protected and virtual, the class allows potential subclasses to override this specific method to return a subtype of 'StringTemplateViewResolver' (or a configured instance) without needing to rewrite the logic in 'createResolver(ServletConfig)' or 'init'.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The method 'createResolver(ServletConfig)' functions as a Template Method. It defines the skeleton of the algorithm for setting up the view resolver by enforcing a specific sequence of steps: instantiation ('createResolver()'), parameter binding ('initParameters'), and context setup ('initContexts'). These steps are broken out into distinct protected methods, allowing subclasses to redefine specific steps of the initialization process without changing the overarching algorithm structure.""
		}
	]
}
```",31.987184
DPD-wayback-ReplayRendererDecorator.java,decorator,gpt-5,Decorator,92,86,"ReplayRendererDecorator implements the same interface (ReplayRenderer) as the wrapped object and holds a reference to a ReplayRenderer (field 'decorated'), with constructors, getter, and setter to wrap another renderer. This structure enables behavior extension via composition and potential chaining. Adherence is slightly reduced because there is no default pass-through implementation of renderResource; delegation is left to concrete subclasses.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 92,
      ""adherence"": 86,
      ""reason"": ""ReplayRendererDecorator implements the same interface (ReplayRenderer) as the wrapped object and holds a reference to a ReplayRenderer (field 'decorated'), with constructors, getter, and setter to wrap another renderer. This structure enables behavior extension via composition and potential chaining. Adherence is slightly reduced because there is no default pass-through implementation of renderResource; delegation is left to concrete subclasses.""
    }
  ]
}",15.579826
DPD-wayback-ReplayRendererDecorator.java,decorator,gemini-3.0-pro,Decorator,98,85,"The class 'ReplayRendererDecorator' implements the 'ReplayRenderer' interface while maintaining a reference field ('decorated') of the same interface type. This structure allows the class (and its concrete subclasses) to wrap an existing 'ReplayRenderer' instance. This 'is-a' and 'has-a' relationship with the same interface is the structural signature of the Decorator pattern. The adherence is slightly lowered because this abstract base class does not implement the default delegation logic for 'renderResource', forcing subclasses to manually implement the call to the decorated object.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 98,
		""adherence"": 85,
		""reason"": ""The class 'ReplayRendererDecorator' implements the 'ReplayRenderer' interface while maintaining a reference field ('decorated') of the same interface type. This structure allows the class (and its concrete subclasses) to wrap an existing 'ReplayRenderer' instance. This 'is-a' and 'has-a' relationship with the same interface is the structural signature of the Decorator pattern. The adherence is slightly lowered because this abstract base class does not implement the default delegation logic for 'renderResource', forcing subclasses to manually implement the call to the decorated object.""
	}]
}
```",20.669532
DPD-fuzzydb-IDecorator.java,decorator,gpt-5,Strategy,62,60,"IDecorator defines a family of interchangeable algorithms for converting and rendering BaseAttribute instances (getValueString, render), likely chosen per attribute type via getAttrName(). It encapsulates the formatting behavior used by BaseAttribute.toString(), fitting the Strategy intent. It does not wrap BaseAttribute nor implement the same interface as BaseAttribute, so despite the name it is not the Decorator pattern.","{""design_patterns"":[{""pattern"":""Strategy"",""confidence"":62,""adherence"":60,""reason"":""IDecorator defines a family of interchangeable algorithms for converting and rendering BaseAttribute instances (getValueString, render), likely chosen per attribute type via getAttrName(). It encapsulates the formatting behavior used by BaseAttribute.toString(), fitting the Strategy intent. It does not wrap BaseAttribute nor implement the same interface as BaseAttribute, so despite the name it is not the Decorator pattern.""}]}",25.367782
DPD-fuzzydb-IDecorator.java,decorator,gemini-3.0-pro,Strategy,90,95,"Despite the interface name 'IDecorator', the code exhibits the Strategy pattern. The interface defines a family of algorithms (rendering logic via 'render' and 'getValueString') that are intended to be used interchangeably by a context object ('BaseAttribute'). The Javadoc note ('called by BaseAttribute.toString()') confirms that the context delegates the rendering behavior to this interface, allowing the string representation logic to vary independently of the data object. It does not fit the Decorator pattern because it accepts the object as a parameter rather than wrapping it via a shared interface.","```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 90,
      ""adherence"": 95,
      ""reason"": ""Despite the interface name 'IDecorator', the code exhibits the Strategy pattern. The interface defines a family of algorithms (rendering logic via 'render' and 'getValueString') that are intended to be used interchangeably by a context object ('BaseAttribute'). The Javadoc note ('called by BaseAttribute.toString()') confirms that the context delegates the rendering behavior to this interface, allowing the string representation logic to vary independently of the data object. It does not fit the Decorator pattern because it accepts the object as a parameter rather than wrapping it via a shared interface.""
    }
  ]
}
```",26.249399
PMART-PMARt-InternalWrapperContext.java,decorator,gpt-5,Decorator,72,65,"The interface explicitly supports wrapping contexts (""interface for internal context wrapping functionality""). Methods like getInternalUserContext() expose the wrapped component, getBaseContext() exposes the root of a wrapper chain, and localPut(...) ensures operations target the top-level wrapper. These are characteristic of a decorator stack where each wrapper may add behavior while delegating to an underlying component.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 72,
      ""adherence"": 65,
      ""reason"": ""The interface explicitly supports wrapping contexts (\""interface for internal context wrapping functionality\""). Methods like getInternalUserContext() expose the wrapped component, getBaseContext() exposes the root of a wrapper chain, and localPut(...) ensures operations target the top-level wrapper. These are characteristic of a decorator stack where each wrapper may add behavior while delegating to an underlying component.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The design distinguishes a user-facing Context and an InternalContextAdapter (\""base full context impl\""), suggesting adaptation from a user Context to an internal engine-facing contract. While this file is only an interface and does not show the adapting logic, the separation of user context vs. internal adapter and the ability to access both aligns with an Adapter arrangement.""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""The mention of \""possible wrapped contexts\"" and ensuring localPut(...) affects the top-level implies a chain through which operations could traverse. However, this interface alone does not show request forwarding/handling decisions typical of CoR; thus, evidence is limited and adherence is low.""
    }
  ]
}",28.594304
PMART-PMARt-InternalWrapperContext.java,decorator,gpt-5,Adapter,60,50,"The design distinguishes a user-facing Context and an InternalContextAdapter (""base full context impl""), suggesting adaptation from a user Context to an internal engine-facing contract. While this file is only an interface and does not show the adapting logic, the separation of user context vs. internal adapter and the ability to access both aligns with an Adapter arrangement.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 72,
      ""adherence"": 65,
      ""reason"": ""The interface explicitly supports wrapping contexts (\""interface for internal context wrapping functionality\""). Methods like getInternalUserContext() expose the wrapped component, getBaseContext() exposes the root of a wrapper chain, and localPut(...) ensures operations target the top-level wrapper. These are characteristic of a decorator stack where each wrapper may add behavior while delegating to an underlying component.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The design distinguishes a user-facing Context and an InternalContextAdapter (\""base full context impl\""), suggesting adaptation from a user Context to an internal engine-facing contract. While this file is only an interface and does not show the adapting logic, the separation of user context vs. internal adapter and the ability to access both aligns with an Adapter arrangement.""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""The mention of \""possible wrapped contexts\"" and ensuring localPut(...) affects the top-level implies a chain through which operations could traverse. However, this interface alone does not show request forwarding/handling decisions typical of CoR; thus, evidence is limited and adherence is low.""
    }
  ]
}",28.594304
PMART-PMARt-InternalWrapperContext.java,decorator,gpt-5,Chain of Responsibility,35,30,"The mention of ""possible wrapped contexts"" and ensuring localPut(...) affects the top-level implies a chain through which operations could traverse. However, this interface alone does not show request forwarding/handling decisions typical of CoR; thus, evidence is limited and adherence is low.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 72,
      ""adherence"": 65,
      ""reason"": ""The interface explicitly supports wrapping contexts (\""interface for internal context wrapping functionality\""). Methods like getInternalUserContext() expose the wrapped component, getBaseContext() exposes the root of a wrapper chain, and localPut(...) ensures operations target the top-level wrapper. These are characteristic of a decorator stack where each wrapper may add behavior while delegating to an underlying component.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The design distinguishes a user-facing Context and an InternalContextAdapter (\""base full context impl\""), suggesting adaptation from a user Context to an internal engine-facing contract. While this file is only an interface and does not show the adapting logic, the separation of user context vs. internal adapter and the ability to access both aligns with an Adapter arrangement.""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""The mention of \""possible wrapped contexts\"" and ensuring localPut(...) affects the top-level implies a chain through which operations could traverse. However, this interface alone does not show request forwarding/handling decisions typical of CoR; thus, evidence is limited and adherence is low.""
    }
  ]
}",28.594304
PMART-PMARt-InternalWrapperContext.java,decorator,gemini-3.0-pro,Decorator,90,85,"The interface is explicitly defined to support 'wrapping functionality' (also known as the Wrapper pattern). The method 'getInternalUserContext()' mandates that the implementing class must hold and expose a reference to a wrapped 'Context' object. Additionally, the 'localPut' method suggests that the wrapper adds specific behavior (local scope management) on top of the wrapped context, which is the core intent of the Decorator pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 90,
		""adherence"": 85,
		""reason"": ""The interface is explicitly defined to support 'wrapping functionality' (also known as the Wrapper pattern). The method 'getInternalUserContext()' mandates that the implementing class must hold and expose a reference to a wrapped 'Context' object. Additionally, the 'localPut' method suggests that the wrapper adds specific behavior (local scope management) on top of the wrapped context, which is the core intent of the Decorator pattern.""
	}]
}
```",25.303758
PMART-Azureus-HashWrapper.java,decorator,gpt-5,Adapter,65,55,"The class wraps a byte[] to adapt its behavior so it can be used as a Map/Set key with value-based equality and hashing (arrays in Java have identity-based equals/hashCode). It uses composition and overrides equals/hashCode, effectively adapting the semantics clients expect. However, adherence is weakened because getHash exposes the internal array, allowing mutation that can break the equals/hashCode contract (hash_code is cached and would become inconsistent if the array contents change). Fields are also not final, reducing immutability guarantees.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 65,
      ""adherence"": 55,
      ""reason"": ""The class wraps a byte[] to adapt its behavior so it can be used as a Map/Set key with value-based equality and hashing (arrays in Java have identity-based equals/hashCode). It uses composition and overrides equals/hashCode, effectively adapting the semantics clients expect. However, adherence is weakened because getHash exposes the internal array, allowing mutation that can break the equals/hashCode contract (hash_code is cached and would become inconsistent if the array contents change). Fields are also not final, reducing immutability guarantees.""
    }
  ]
}",27.035308
PMART-Azureus-HashWrapper.java,decorator,gemini-3.0-pro,Immutable Object,95,60,"The class pre-calculates and caches the 'hash_code' in the constructor, which implies the internal state is intended to remain constant for the object's lifecycle. However, strict adherence is compromised because the 'getHash()' method returns a direct reference to the mutable 'hash' byte array instead of returning a defensive copy, allowing external modification of the state.","Based on the analysis of the provided `HashWrapper` class, the code exhibits the characteristics of the **Immutable Object** pattern (often associated with Value Objects), though with a specific flaw regarding the ""missing parts"" hint. Additionally, it functionally acts as an **Adapter** to make byte arrays compatible with Collection keys.

Here is the analysis in JSON format:

```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Immutable Object"",
      ""confidence"": 95,
      ""adherence"": 60,
      ""reason"": ""The class pre-calculates and caches the 'hash_code' in the constructor, which implies the internal state is intended to remain constant for the object's lifecycle. However, strict adherence is compromised because the 'getHash()' method returns a direct reference to the mutable 'hash' byte array instead of returning a defensive copy, allowing external modification of the state.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 85,
      ""adherence"": 100,
      ""reason"": ""The class wraps a primitive 'byte[]' (which relies on reference identity) and adapts it to fulfill the 'java.lang.Object' contract for 'equals()' and 'hashCode()' based on content. This allows the byte array to be used effectively as a key in Hash-based collections (like HashMap), adapting the array interface to the Collection framework's requirements.""
    }
  ]
}
```",66.38198
PMART-Azureus-HashWrapper.java,decorator,gemini-3.0-pro,Adapter,85,100,"The class wraps a primitive 'byte[]' (which relies on reference identity) and adapts it to fulfill the 'java.lang.Object' contract for 'equals()' and 'hashCode()' based on content. This allows the byte array to be used effectively as a key in Hash-based collections (like HashMap), adapting the array interface to the Collection framework's requirements.","Based on the analysis of the provided `HashWrapper` class, the code exhibits the characteristics of the **Immutable Object** pattern (often associated with Value Objects), though with a specific flaw regarding the ""missing parts"" hint. Additionally, it functionally acts as an **Adapter** to make byte arrays compatible with Collection keys.

Here is the analysis in JSON format:

```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Immutable Object"",
      ""confidence"": 95,
      ""adherence"": 60,
      ""reason"": ""The class pre-calculates and caches the 'hash_code' in the constructor, which implies the internal state is intended to remain constant for the object's lifecycle. However, strict adherence is compromised because the 'getHash()' method returns a direct reference to the mutable 'hash' byte array instead of returning a defensive copy, allowing external modification of the state.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 85,
      ""adherence"": 100,
      ""reason"": ""The class wraps a primitive 'byte[]' (which relies on reference identity) and adapts it to fulfill the 'java.lang.Object' contract for 'equals()' and 'hashCode()' based on content. This allows the byte array to be used effectively as a key in Hash-based collections (like HashMap), adapting the array interface to the Collection framework's requirements.""
    }
  ]
}
```",66.38198
PMART-Xerces-DOMErrorHandlerWrapper.java,decorator,gpt-5,Adapter,95,92,"The class implements XMLErrorHandler and converts XNI XMLParseException-based callbacks (warning/error/fatalError) into DOMError by populating a DOMErrorImpl/DOMLocatorImpl, then delegates to a provided DOMErrorHandler (fDomErrorHandler). This bridges two incompatible interfaces (XNI error handling -> DOM Level 3 error handling) via composition and translation. Although the class also implements DOMErrorHandler itself, the adaptation path is clearly directional (XMLErrorHandler -> DOMErrorHandler), fitting the Adapter pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""The class implements XMLErrorHandler and converts XNI XMLParseException-based callbacks (warning/error/fatalError) into DOMError by populating a DOMErrorImpl/DOMLocatorImpl, then delegates to a provided DOMErrorHandler (fDomErrorHandler). This bridges two incompatible interfaces (XNI error handling -> DOM Level 3 error handling) via composition and translation. Although the class also implements DOMErrorHandler itself, the adaptation path is clearly directional (XMLErrorHandler -> DOMErrorHandler), fitting the Adapter pattern.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The class serves as a callback target by implementing XMLErrorHandler/DOMErrorHandler and is intended to be registered with a parser that emits error events. This reflects the Observer pattern (publisher-subscriber), where the parser is the subject and this class is an observer. Only the observer side is visible here; the subject and observer management are outside this snippet.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 45,
      ""adherence"": 55,
      ""reason"": ""The field fDomErrorHandler is a pluggable policy for handling DOMError; setErrorHandler allows swapping behavior at runtime. This class plays the role of a context delegating to a Strategy (DOMErrorHandler). However, the primary intent is adaptation rather than selecting among multiple algorithms, so evidence is partial.""
    }
  ]
}",47.087139
PMART-Xerces-DOMErrorHandlerWrapper.java,decorator,gpt-5,Observer,60,50,"The class serves as a callback target by implementing XMLErrorHandler/DOMErrorHandler and is intended to be registered with a parser that emits error events. This reflects the Observer pattern (publisher-subscriber), where the parser is the subject and this class is an observer. Only the observer side is visible here; the subject and observer management are outside this snippet.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""The class implements XMLErrorHandler and converts XNI XMLParseException-based callbacks (warning/error/fatalError) into DOMError by populating a DOMErrorImpl/DOMLocatorImpl, then delegates to a provided DOMErrorHandler (fDomErrorHandler). This bridges two incompatible interfaces (XNI error handling -> DOM Level 3 error handling) via composition and translation. Although the class also implements DOMErrorHandler itself, the adaptation path is clearly directional (XMLErrorHandler -> DOMErrorHandler), fitting the Adapter pattern.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The class serves as a callback target by implementing XMLErrorHandler/DOMErrorHandler and is intended to be registered with a parser that emits error events. This reflects the Observer pattern (publisher-subscriber), where the parser is the subject and this class is an observer. Only the observer side is visible here; the subject and observer management are outside this snippet.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 45,
      ""adherence"": 55,
      ""reason"": ""The field fDomErrorHandler is a pluggable policy for handling DOMError; setErrorHandler allows swapping behavior at runtime. This class plays the role of a context delegating to a Strategy (DOMErrorHandler). However, the primary intent is adaptation rather than selecting among multiple algorithms, so evidence is partial.""
    }
  ]
}",47.087139
PMART-Xerces-DOMErrorHandlerWrapper.java,decorator,gpt-5,Strategy,45,55,"The field fDomErrorHandler is a pluggable policy for handling DOMError; setErrorHandler allows swapping behavior at runtime. This class plays the role of a context delegating to a Strategy (DOMErrorHandler). However, the primary intent is adaptation rather than selecting among multiple algorithms, so evidence is partial.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""The class implements XMLErrorHandler and converts XNI XMLParseException-based callbacks (warning/error/fatalError) into DOMError by populating a DOMErrorImpl/DOMLocatorImpl, then delegates to a provided DOMErrorHandler (fDomErrorHandler). This bridges two incompatible interfaces (XNI error handling -> DOM Level 3 error handling) via composition and translation. Although the class also implements DOMErrorHandler itself, the adaptation path is clearly directional (XMLErrorHandler -> DOMErrorHandler), fitting the Adapter pattern.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 60,
      ""adherence"": 50,
      ""reason"": ""The class serves as a callback target by implementing XMLErrorHandler/DOMErrorHandler and is intended to be registered with a parser that emits error events. This reflects the Observer pattern (publisher-subscriber), where the parser is the subject and this class is an observer. Only the observer side is visible here; the subject and observer management are outside this snippet.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 45,
      ""adherence"": 55,
      ""reason"": ""The field fDomErrorHandler is a pluggable policy for handling DOMError; setErrorHandler allows swapping behavior at runtime. This class plays the role of a context delegating to a Strategy (DOMErrorHandler). However, the primary intent is adaptation rather than selecting among multiple algorithms, so evidence is partial.""
    }
  ]
}",47.087139
PMART-Xerces-DOMErrorHandlerWrapper.java,decorator,gemini-3.0-pro,Adapter,98,100,"The class `DOMErrorHandlerWrapper` acts as an Adapter between the `XMLErrorHandler` interface (the Target) and the `DOMErrorHandler` interface (the Adaptee). It implements `XMLErrorHandler` to receive parser callbacks (`warning`, `error`, `fatalError`) and holds a reference to a `DOMErrorHandler` (`fDomErrorHandler`). Inside these methods, it translates the incompatible inputs (converting `XMLParseException` and strings into a `DOMError` object) and delegates the execution to the wrapped `fDomErrorHandler`. This allows an application's DOM error handler to be used by the Xerces XNI parser.","```json
{
	""design_patterns"": [{
		""pattern"": ""Adapter"",
		""confidence"": 98,
		""adherence"": 100,
		""reason"": ""The class `DOMErrorHandlerWrapper` acts as an Adapter between the `XMLErrorHandler` interface (the Target) and the `DOMErrorHandler` interface (the Adaptee). It implements `XMLErrorHandler` to receive parser callbacks (`warning`, `error`, `fatalError`) and holds a reference to a `DOMErrorHandler` (`fDomErrorHandler`). Inside these methods, it translates the incompatible inputs (converting `XMLParseException` and strings into a `DOMError` object) and delegates the execution to the wrapped `fDomErrorHandler`. This allows an application's DOM error handler to be used by the Xerces XNI parser.""
	}]
}
```",20.296151
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gpt-5,Adapter,95,95,"The class wraps a TIntByteHashMap and exposes the java.util.Map interface. It translates between Object-based keys/values (Integer/Byte) and primitive ints/bytes via wrap/unwrap methods and delegates all operations to the underlying primitive map, adapting one interface to another.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""The class wraps a TIntByteHashMap and exposes the java.util.Map interface. It translates between Object-based keys/values (Integer/Byte) and primitive ints/bytes via wrap/unwrap methods and delegates all operations to the underlying primitive map, adapting one interface to another.""
    },
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 80,
      ""adherence"": 90,
      ""reason"": ""entrySet().iterator() returns a java.util.Iterator that internally uses a TIntByteIterator and adapts primitive keys/values to Map.Entry objects. The anonymous iterator implements hasNext/next/remove by delegating to the underlying primitive iterator.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 60,
      ""adherence"": 70,
      ""reason"": ""By extending AbstractMap and providing entrySet (and related overrides), the class participates in the AbstractMap template where the abstract base class implements parts of Map behavior based on subclass-provided hooks like entrySet.""
    }
  ]
}",51.042287
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gpt-5,Iterator,80,90,entrySet().iterator() returns a java.util.Iterator that internally uses a TIntByteIterator and adapts primitive keys/values to Map.Entry objects. The anonymous iterator implements hasNext/next/remove by delegating to the underlying primitive iterator.,"{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""The class wraps a TIntByteHashMap and exposes the java.util.Map interface. It translates between Object-based keys/values (Integer/Byte) and primitive ints/bytes via wrap/unwrap methods and delegates all operations to the underlying primitive map, adapting one interface to another.""
    },
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 80,
      ""adherence"": 90,
      ""reason"": ""entrySet().iterator() returns a java.util.Iterator that internally uses a TIntByteIterator and adapts primitive keys/values to Map.Entry objects. The anonymous iterator implements hasNext/next/remove by delegating to the underlying primitive iterator.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 60,
      ""adherence"": 70,
      ""reason"": ""By extending AbstractMap and providing entrySet (and related overrides), the class participates in the AbstractMap template where the abstract base class implements parts of Map behavior based on subclass-provided hooks like entrySet.""
    }
  ]
}",51.042287
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gpt-5,Template Method,60,70,"By extending AbstractMap and providing entrySet (and related overrides), the class participates in the AbstractMap template where the abstract base class implements parts of Map behavior based on subclass-provided hooks like entrySet.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""The class wraps a TIntByteHashMap and exposes the java.util.Map interface. It translates between Object-based keys/values (Integer/Byte) and primitive ints/bytes via wrap/unwrap methods and delegates all operations to the underlying primitive map, adapting one interface to another.""
    },
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 80,
      ""adherence"": 90,
      ""reason"": ""entrySet().iterator() returns a java.util.Iterator that internally uses a TIntByteIterator and adapts primitive keys/values to Map.Entry objects. The anonymous iterator implements hasNext/next/remove by delegating to the underlying primitive iterator.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 60,
      ""adherence"": 70,
      ""reason"": ""By extending AbstractMap and providing entrySet (and related overrides), the class participates in the AbstractMap template where the abstract base class implements parts of Map behavior based on subclass-provided hooks like entrySet.""
    }
  ]
}",51.042287
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gemini-3.0-pro,Adapter,100,100,"Despite the class name 'TIntByteHashMapDecorator', this is structurally an implementation of the Adapter pattern (specifically an Object Adapter). The class implements the 'java.util.Map' interface (the Target) but delegates functionality to the wrapped 'TIntByteHashMap' instance (the Adaptee). It translates the specific primitive-based interface of the Adaptee (int/byte) into the generic Object-based interface required by the Target, utilizing helper methods like 'wrapKey' and 'unwrapKey' to bridge the incompatibility.","```json
{
	""design_patterns"": [{
			""pattern"": ""Adapter"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""Despite the class name 'TIntByteHashMapDecorator', this is structurally an implementation of the Adapter pattern (specifically an Object Adapter). The class implements the 'java.util.Map' interface (the Target) but delegates functionality to the wrapped 'TIntByteHashMap' instance (the Adaptee). It translates the specific primitive-based interface of the Adaptee (int/byte) into the generic Object-based interface required by the Target, utilizing helper methods like 'wrapKey' and 'unwrapKey' to bridge the incompatibility.""
		},
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""In the 'entrySet' method, the code returns an anonymous inner class that implements 'java.util.Iterator'. This implementation provides sequential access to the elements of the underlying collection without exposing its internal representation. It delegates to the internal Trove iterator ('TIntByteIterator') while adapting the returned values to standard 'Map.Entry' objects.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class implements the 'Cloneable' interface and overrides the 'clone' method. It manually handles the creation of a new instance and performs a deep copy of the underlying '_map' reference, allowing the object to create a copy of itself.""
		}
	]
}
```",35.387275
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gemini-3.0-pro,Iterator,100,100,"In the 'entrySet' method, the code returns an anonymous inner class that implements 'java.util.Iterator'. This implementation provides sequential access to the elements of the underlying collection without exposing its internal representation. It delegates to the internal Trove iterator ('TIntByteIterator') while adapting the returned values to standard 'Map.Entry' objects.","```json
{
	""design_patterns"": [{
			""pattern"": ""Adapter"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""Despite the class name 'TIntByteHashMapDecorator', this is structurally an implementation of the Adapter pattern (specifically an Object Adapter). The class implements the 'java.util.Map' interface (the Target) but delegates functionality to the wrapped 'TIntByteHashMap' instance (the Adaptee). It translates the specific primitive-based interface of the Adaptee (int/byte) into the generic Object-based interface required by the Target, utilizing helper methods like 'wrapKey' and 'unwrapKey' to bridge the incompatibility.""
		},
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""In the 'entrySet' method, the code returns an anonymous inner class that implements 'java.util.Iterator'. This implementation provides sequential access to the elements of the underlying collection without exposing its internal representation. It delegates to the internal Trove iterator ('TIntByteIterator') while adapting the returned values to standard 'Map.Entry' objects.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class implements the 'Cloneable' interface and overrides the 'clone' method. It manually handles the creation of a new instance and performs a deep copy of the underlying '_map' reference, allowing the object to create a copy of itself.""
		}
	]
}
```",35.387275
PMART-PMARt-TIntByteHashMapDecorator.java,decorator,gemini-3.0-pro,Prototype,95,90,"The class implements the 'Cloneable' interface and overrides the 'clone' method. It manually handles the creation of a new instance and performs a deep copy of the underlying '_map' reference, allowing the object to create a copy of itself.","```json
{
	""design_patterns"": [{
			""pattern"": ""Adapter"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""Despite the class name 'TIntByteHashMapDecorator', this is structurally an implementation of the Adapter pattern (specifically an Object Adapter). The class implements the 'java.util.Map' interface (the Target) but delegates functionality to the wrapped 'TIntByteHashMap' instance (the Adaptee). It translates the specific primitive-based interface of the Adaptee (int/byte) into the generic Object-based interface required by the Target, utilizing helper methods like 'wrapKey' and 'unwrapKey' to bridge the incompatibility.""
		},
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""In the 'entrySet' method, the code returns an anonymous inner class that implements 'java.util.Iterator'. This implementation provides sequential access to the elements of the underlying collection without exposing its internal representation. It delegates to the internal Trove iterator ('TIntByteIterator') while adapting the returned values to standard 'Map.Entry' objects.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class implements the 'Cloneable' interface and overrides the 'clone' method. It manually handles the creation of a new instance and performs a deep copy of the underlying '_map' reference, allowing the object to create a copy of itself.""
		}
	]
}
```",35.387275
DPD-freemind-ConditionNotSatisfiedDecorator.java,decorator,gpt-5,Decorator,95,88,"ConditionNotSatisfiedDecorator implements the same interface (Condition), holds a reference to another Condition, and augments behavior by delegating and altering results (negates checkNode, composes renderer output, and wraps persistence). The only slight deviation is passing null instead of the provided Controller to the wrapped condition in checkNode, which may affect substitutability.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 88,
      ""reason"": ""ConditionNotSatisfiedDecorator implements the same interface (Condition), holds a reference to another Condition, and augments behavior by delegating and altering results (negates checkNode, composes renderer output, and wraps persistence). The only slight deviation is passing null instead of the provided Controller to the wrapped condition in checkNode, which may affect substitutability.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 55,
      ""adherence"": 70,
      ""reason"": ""The static load method defers creation of the wrapped Condition to a factory obtained via FilterController.getConditionFactory().loadCondition(...), encapsulating instantiation based on XML. While the class uses a factory method rather than defining the pattern itself, the usage aligns with factory-based object creation; details of the factory hierarchy are not visible here.""
    }
  ]
}",76.178354
DPD-freemind-ConditionNotSatisfiedDecorator.java,decorator,gpt-5,Factory Method,55,70,"The static load method defers creation of the wrapped Condition to a factory obtained via FilterController.getConditionFactory().loadCondition(...), encapsulating instantiation based on XML. While the class uses a factory method rather than defining the pattern itself, the usage aligns with factory-based object creation; details of the factory hierarchy are not visible here.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 88,
      ""reason"": ""ConditionNotSatisfiedDecorator implements the same interface (Condition), holds a reference to another Condition, and augments behavior by delegating and altering results (negates checkNode, composes renderer output, and wraps persistence). The only slight deviation is passing null instead of the provided Controller to the wrapped condition in checkNode, which may affect substitutability.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 55,
      ""adherence"": 70,
      ""reason"": ""The static load method defers creation of the wrapped Condition to a factory obtained via FilterController.getConditionFactory().loadCondition(...), encapsulating instantiation based on XML. While the class uses a factory method rather than defining the pattern itself, the usage aligns with factory-based object creation; details of the factory hierarchy are not visible here.""
    }
  ]
}",76.178354
DPD-freemind-ConditionNotSatisfiedDecorator.java,decorator,gemini-3.0-pro,Decorator,100,100,"The class 'ConditionNotSatisfiedDecorator' implements the 'Condition' interface and holds a private reference to another 'Condition' object ('originalCondition'). It initializes this reference via the constructor. In the 'checkNode' method, it calls the wrapped object's method and modifies the result (negates it). Similarly, 'getListCellRendererComponent' calls the wrapped object's method and decorates the result with a JLabel. This structure of wrapping an object of the same interface to add behavior dynamically is the definition of the Decorator pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'ConditionNotSatisfiedDecorator' implements the 'Condition' interface and holds a private reference to another 'Condition' object ('originalCondition'). It initializes this reference via the constructor. In the 'checkNode' method, it calls the wrapped object's method and modifies the result (negates it). Similarly, 'getListCellRendererComponent' calls the wrapped object's method and decorates the result with a JLabel. This structure of wrapping an object of the same interface to add behavior dynamically is the definition of the Decorator pattern.""
	}]
}
```",23.712948
DPD-cdt-CNavigatorProblemsLabelDecorator.java,decorator,gpt-5,Decorator,90,80,"The class extends ProblemsLabelDecorator, a label decorator in Eclipse that augments label presentation (e.g., overlays for problems) without changing the underlying objects or client usage. CNavigatorProblemsLabelDecorator preserves the same role/interface while specializing behavior for the Common Navigator (optimizing the change notification), fitting the Decorator intent.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 90,
      ""adherence"": 80,
      ""reason"": ""The class extends ProblemsLabelDecorator, a label decorator in Eclipse that augments label presentation (e.g., overlays for problems) without changing the underlying objects or client usage. CNavigatorProblemsLabelDecorator preserves the same role/interface while specializing behavior for the Common Navigator (optimizing the change notification), fitting the Decorator intent.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The subclass overrides a protected hook method (fireProblemsChanged) to tweak a step in the parent’s event/refresh algorithm (e.g., coalescing many changes by passing null), then delegates to super. This is characteristic of a hook within a Template Method where the superclass defines the workflow and subclasses customize a step.""
    }
  ]
}",22.506528
DPD-cdt-CNavigatorProblemsLabelDecorator.java,decorator,gpt-5,Template Method,60,60,"The subclass overrides a protected hook method (fireProblemsChanged) to tweak a step in the parent’s event/refresh algorithm (e.g., coalescing many changes by passing null), then delegates to super. This is characteristic of a hook within a Template Method where the superclass defines the workflow and subclasses customize a step.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 90,
      ""adherence"": 80,
      ""reason"": ""The class extends ProblemsLabelDecorator, a label decorator in Eclipse that augments label presentation (e.g., overlays for problems) without changing the underlying objects or client usage. CNavigatorProblemsLabelDecorator preserves the same role/interface while specializing behavior for the Common Navigator (optimizing the change notification), fitting the Decorator intent.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The subclass overrides a protected hook method (fireProblemsChanged) to tweak a step in the parent’s event/refresh algorithm (e.g., coalescing many changes by passing null), then delegates to super. This is characteristic of a hook within a Template Method where the superclass defines the workflow and subclasses customize a step.""
    }
  ]
}",22.506528
DPD-cdt-CNavigatorProblemsLabelDecorator.java,decorator,gemini-3.0-pro,Observer,90,50,"The class overrides 'fireProblemsChanged', a method explicitly designed to notify listeners of state changes (Publisher/Subject role). The code implements specific logic to optimize the notification payload (forcing a full refresh by setting the resource list to null) before delegating the actual event firing to the superclass.","Based on the analysis of the source code provided, here is the JSON output detecting the design patterns.

The analysis highlights that while the class name suggests the **Decorator** pattern, the implementation utilizes inheritance without composition (passing `null` to the super constructor), which does not adhere to the structural requirements of the standard GoF Decorator pattern. However, the method `fireProblemsChanged` clearly indicates participation in the **Observer** pattern (as a Publisher/Subject).

```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 90,
		""adherence"": 50,
		""reason"": ""The class overrides 'fireProblemsChanged', a method explicitly designed to notify listeners of state changes (Publisher/Subject role). The code implements specific logic to optimize the notification payload (forcing a full refresh by setting the resource list to null) before delegating the actual event firing to the superclass.""
	}]
}
```",58.258369
DPD-junit5-RunnerDecorator.java,decorator,gpt-5,Decorator,25,15,"The interface name suggests decoration, but it does not implement or extend Runner (the component it would need to mimic). A classic Decorator must conform to the same interface as the component and delegate to a wrapped instance. Here we only see getDecoratedRunner() returning a Runner with no evidence of wrapping/delegation or concrete implementations. This looks more like a provider/factory for a Runner than a true Decorator, so adherence is very low and cannot be confirmed from this snippet alone.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 25,
      ""adherence"": 15,
      ""reason"": ""The interface name suggests decoration, but it does not implement or extend Runner (the component it would need to mimic). A classic Decorator must conform to the same interface as the component and delegate to a wrapped instance. Here we only see getDecoratedRunner() returning a Runner with no evidence of wrapping/delegation or concrete implementations. This looks more like a provider/factory for a Runner than a true Decorator, so adherence is very low and cannot be confirmed from this snippet alone.""
    }
  ]
}",39.54551
DPD-junit5-RunnerDecorator.java,decorator,gemini-3.0-pro,None,0,0,No pattern detected or parse error,"```json
{
  ""design_patterns"": []
}
```",36.71721
PMART-Xerces-DOMEntityResolverWrapper.java,decorator,gpt-5,Adapter,95,95,"The class implements XMLEntityResolver while holding an LSResourceResolver and translating between the two APIs. resolveEntity delegates to LSResourceResolver.resolveResource and converts the returned LSInput into an XMLInputSource (mapping streams, encoding, IDs, and determining type via getType). This is a classic object adapter using composition to adapt one interface to another.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""The class implements XMLEntityResolver while holding an LSResourceResolver and translating between the two APIs. resolveEntity delegates to LSResourceResolver.resolveResource and converts the returned LSInput into an XMLInputSource (mapping streams, encoding, IDs, and determining type via getType). This is a classic object adapter using composition to adapt one interface to another.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 60,
      ""reason"": ""The resolution behavior is pluggable via the LSResourceResolver field set by setEntityResolver. DOMEntityResolverWrapper acts as a context delegating resolution to the provided strategy (any LSResourceResolver implementation). However, the primary intent is adaptation rather than defining a family of algorithms, so adherence is moderate.""
    }
  ]
}",36.827718
PMART-Xerces-DOMEntityResolverWrapper.java,decorator,gpt-5,Strategy,55,60,"The resolution behavior is pluggable via the LSResourceResolver field set by setEntityResolver. DOMEntityResolverWrapper acts as a context delegating resolution to the provided strategy (any LSResourceResolver implementation). However, the primary intent is adaptation rather than defining a family of algorithms, so adherence is moderate.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""The class implements XMLEntityResolver while holding an LSResourceResolver and translating between the two APIs. resolveEntity delegates to LSResourceResolver.resolveResource and converts the returned LSInput into an XMLInputSource (mapping streams, encoding, IDs, and determining type via getType). This is a classic object adapter using composition to adapt one interface to another.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 60,
      ""reason"": ""The resolution behavior is pluggable via the LSResourceResolver field set by setEntityResolver. DOMEntityResolverWrapper acts as a context delegating resolution to the provided strategy (any LSResourceResolver implementation). However, the primary intent is adaptation rather than defining a family of algorithms, so adherence is moderate.""
    }
  ]
}",36.827718
PMART-Xerces-DOMEntityResolverWrapper.java,decorator,gemini-3.0-pro,Adapter,100,100,"The class 'DOMEntityResolverWrapper' functions as an Object Adapter. It implements the 'XMLEntityResolver' interface (the Target) but delegates the actual processing to a contained instance of 'LSResourceResolver' (the Adaptee), stored in the field 'fEntityResolver'. The 'resolveEntity' method translates the call from the XNI interface to the DOM interface by converting parameters and mapping the return type 'LSInput' back to 'XMLInputSource', allowing incompatible interfaces to work together.","```json
{
	""design_patterns"": [{
		""pattern"": ""Adapter"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'DOMEntityResolverWrapper' functions as an Object Adapter. It implements the 'XMLEntityResolver' interface (the Target) but delegates the actual processing to a contained instance of 'LSResourceResolver' (the Adaptee), stored in the field 'fEntityResolver'. The 'resolveEntity' method translates the call from the XNI interface to the DOM interface by converting parameters and mapping the return type 'LSInput' back to 'XMLInputSource', allowing incompatible interfaces to work together.""
	}]
}
```",15.815779
DPD-Get-Another-Label-Decorator.java,decorator,gpt-5,Decorator,78,55,"DatumDecorator wraps a Datum instance (via a superclass Decorator<T>) and adds extra responsibilities (quality/cost computations) by delegating to the wrapped object and Helper utilities. This aligns with the Decorator intent of adding behavior by wrapping. However, it does not appear to implement the same interface/type as Datum (no transparent substitutability) and does not forward the full Datum API, so it only partially adheres to the classic Decorator pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 78,
      ""adherence"": 55,
      ""reason"": ""DatumDecorator wraps a Datum instance (via a superclass Decorator<T>) and adds extra responsibilities (quality/cost computations) by delegating to the wrapped object and Helper utilities. This aligns with the Decorator intent of adding behavior by wrapping. However, it does not appear to implement the same interface/type as Datum (no transparent substitutability) and does not forward the full Datum API, so it only partially adheres to the classic Decorator pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 30,
      ""adherence"": 35,
      ""reason"": ""Multiple algorithm variants are hinted via the ClassificationMethod enum (e.g., DS_Soft, MV_Soft, MinCost) and are selected at call sites. This suggests strategy-like variability, but the selection is parameter-based rather than using distinct Strategy objects with a common interface. Without polymorphic strategy objects or injection, adherence to the GoF Strategy pattern is weak.""
    }
  ]
}",21.998138
DPD-Get-Another-Label-Decorator.java,decorator,gpt-5,Strategy,30,35,"Multiple algorithm variants are hinted via the ClassificationMethod enum (e.g., DS_Soft, MV_Soft, MinCost) and are selected at call sites. This suggests strategy-like variability, but the selection is parameter-based rather than using distinct Strategy objects with a common interface. Without polymorphic strategy objects or injection, adherence to the GoF Strategy pattern is weak.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 78,
      ""adherence"": 55,
      ""reason"": ""DatumDecorator wraps a Datum instance (via a superclass Decorator<T>) and adds extra responsibilities (quality/cost computations) by delegating to the wrapped object and Helper utilities. This aligns with the Decorator intent of adding behavior by wrapping. However, it does not appear to implement the same interface/type as Datum (no transparent substitutability) and does not forward the full Datum API, so it only partially adheres to the classic Decorator pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 30,
      ""adherence"": 35,
      ""reason"": ""Multiple algorithm variants are hinted via the ClassificationMethod enum (e.g., DS_Soft, MV_Soft, MinCost) and are selected at call sites. This suggests strategy-like variability, but the selection is parameter-based rather than using distinct Strategy objects with a common interface. Without polymorphic strategy objects or injection, adherence to the GoF Strategy pattern is weak.""
    }
  ]
}",21.998138
DPD-Get-Another-Label-Decorator.java,decorator,gemini-3.0-pro,Decorator,95,88,"The class explicitly mimics the structure of the Decorator pattern. It extends a base `Decorator` class and accepts an instance of `Datum` in the constructor, establishing a composition relationship (wrapping). It then adds significant new functionality (additional methods for cost and data quality calculations) while delegating core data retrieval to the wrapped `object` instance. Although the specific interface definitions are not visible to confirm strict type interchangeability with `Datum`, the structural implementation of wrapping and behavior expansion is consistent with the pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 95,
		""adherence"": 88,
		""reason"": ""The class explicitly mimics the structure of the Decorator pattern. It extends a base `Decorator` class and accepts an instance of `Datum` in the constructor, establishing a composition relationship (wrapping). It then adds significant new functionality (additional methods for cost and data quality calculations) while delegating core data retrieval to the wrapped `object` instance. Although the specific interface definitions are not visible to confirm strict type interchangeability with `Datum`, the structural implementation of wrapping and behavior expansion is consistent with the pattern.""
	}]
}
```",40.916704
PMART-PMARt-StorageFeedWrapper.java,decorator,gpt-5,Adapter,78,85,"StorageFeedWrapper implements the StorageWrapper interface (target) and adapts a ServerBaseFeed (adaptee) to produce a Lucene Document that the storage layer expects. It composes the adaptee, translates its data (including generating Atom XML) into the target representation (Document fields), and exposes the expected method getLuceneDocument(). It does not preserve the adaptee's interface (so not a Decorator/Proxy), nor does it define an abstract creation hierarchy (so not Factory Method).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 78,
      ""adherence"": 85,
      ""reason"": ""StorageFeedWrapper implements the StorageWrapper interface (target) and adapts a ServerBaseFeed (adaptee) to produce a Lucene Document that the storage layer expects. It composes the adaptee, translates its data (including generating Atom XML) into the target representation (Document fields), and exposes the expected method getLuceneDocument(). It does not preserve the adaptee's interface (so not a Decorator/Proxy), nor does it define an abstract creation hierarchy (so not Factory Method).""
    }
  ]
}",18.039959
PMART-PMARt-StorageFeedWrapper.java,decorator,gemini-3.0-pro,Adapter,95,100,The class 'StorageFeedWrapper' acts as an Object Adapter. It implements the 'StorageWrapper' interface (the Target) and holds a private reference to the 'ServerBaseFeed' class (the Adaptee). It converts the interface of the GData feed into the interface expected by the storage system by transforming the feed's data into a Lucene 'Document' inside the 'getLuceneDocument' method.,"Based on the analysis of the provided source code, the following design pattern has been detected.

The class `StorageFeedWrapper` is a clear implementation of the **Adapter Pattern** (also known as the Wrapper pattern).

1.  **Target Interface**: `StorageWrapper` (The interface the client expects).
2.  **Adaptee**: `ServerBaseFeed` (The existing class with incompatible interface).
3.  **Adapter**: `StorageFeedWrapper` (The class analyzing).

The `StorageFeedWrapper` implements the `StorageWrapper` interface but wraps a `ServerBaseFeed` instance. It does not simply pass calls through (which would be a Proxy); it **adapts** the data from the `ServerBaseFeed` (getting IDs, service types, generating XML content) into a completely different format: a Lucene `Document` required by the storage system via the `getLuceneDocument()` method.

```json
{
	""design_patterns"": [{
		""pattern"": ""Adapter"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The class 'StorageFeedWrapper' acts as an Object Adapter. It implements the 'StorageWrapper' interface (the Target) and holds a private reference to the 'ServerBaseFeed' class (the Adaptee). It converts the interface of the GData feed into the interface expected by the storage system by transforming the feed's data into a Lucene 'Document' inside the 'getLuceneDocument' method.""
	}]
}
```",30.714027
PMART-PMARt-OutputWrapper.java,decorator,gpt-5,Adapter,60,58,"OutputWrapper subclasses XMLOutputter and exposes a different, simplified interface for clients that want a String of an element's content instead of writing to a Writer. It leverages the protected outputElementContent(...) of the superclass and returns the result as a String, effectively adapting a writer-based API to a string-returning one. This is a class adapter (via inheritance) rather than a composition-based adapter. Adherence is partial: it adds only a single convenience method, does not generally replace the original interface, and the boolean parameter 'strip' is unused, suggesting an incomplete or leaky design.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 60,
      ""adherence"": 58,
      ""reason"": ""OutputWrapper subclasses XMLOutputter and exposes a different, simplified interface for clients that want a String of an element's content instead of writing to a Writer. It leverages the protected outputElementContent(...) of the superclass and returns the result as a String, effectively adapting a writer-based API to a string-returning one. This is a class adapter (via inheritance) rather than a composition-based adapter. Adherence is partial: it adds only a single convenience method, does not generally replace the original interface, and the boolean parameter 'strip' is unused, suggesting an incomplete or leaky design.""
    }
  ]
}",38.401811
PMART-PMARt-OutputWrapper.java,decorator,gemini-3.0-pro,None,0,0,No pattern detected or parse error,"```json
{
  ""design_patterns"": []
}
```",40.568727
PMART-PMARt-LogDisplayWrapper.java,decorator,gpt-5,Decorator,88,68,"The class adds responsibilities to an existing logging abstraction (prefixing messages and conditional logging) while keeping the same type usable by clients (extends Log). It composes another Log and augments behavior without changing client code. However, it does not delegate to the wrapped Log's methods but directly to its LogChute implementor, which prevents stacking multiple decorators and deviates from the canonical delegate-to-wrapped-component structure.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 88,
      ""adherence"": 68,
      ""reason"": ""The class adds responsibilities to an existing logging abstraction (prefixing messages and conditional logging) while keeping the same type usable by clients (extends Log). It composes another Log and augments behavior without changing client code. However, it does not delegate to the wrapped Log's methods but directly to its LogChute implementor, which prevents stacking multiple decorators and deviates from the canonical delegate-to-wrapped-component structure.""
    },
    {
      ""pattern"": ""Bridge"",
      ""confidence"": 62,
      ""adherence"": 70,
      ""reason"": ""Log (abstraction) delegates to a LogChute (implementor). This subclass passes the implementor from the wrapped Log to its superclass and calls getLogChute().log(...), indicating separation of abstraction from implementation. While the file shows only one participant, the structure fits a Bridge where different LogChute implementations can vary independently of Log.""
    }
  ]
}",44.342853
PMART-PMARt-LogDisplayWrapper.java,decorator,gpt-5,Bridge,62,70,"Log (abstraction) delegates to a LogChute (implementor). This subclass passes the implementor from the wrapped Log to its superclass and calls getLogChute().log(...), indicating separation of abstraction from implementation. While the file shows only one participant, the structure fits a Bridge where different LogChute implementations can vary independently of Log.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 88,
      ""adherence"": 68,
      ""reason"": ""The class adds responsibilities to an existing logging abstraction (prefixing messages and conditional logging) while keeping the same type usable by clients (extends Log). It composes another Log and augments behavior without changing client code. However, it does not delegate to the wrapped Log's methods but directly to its LogChute implementor, which prevents stacking multiple decorators and deviates from the canonical delegate-to-wrapped-component structure.""
    },
    {
      ""pattern"": ""Bridge"",
      ""confidence"": 62,
      ""adherence"": 70,
      ""reason"": ""Log (abstraction) delegates to a LogChute (implementor). This subclass passes the implementor from the wrapped Log to its superclass and calls getLogChute().log(...), indicating separation of abstraction from implementation. While the file shows only one participant, the structure fits a Bridge where different LogChute implementations can vary independently of Log.""
    }
  ]
}",44.342853
PMART-PMARt-LogDisplayWrapper.java,decorator,gemini-3.0-pro,Decorator,100,100,"The class 'LogDisplayWrapper' follows the Decorator pattern structure perfectly. 1. It shares the same type as the object it wraps (it extends 'Log'). 2. It holds a reference to an instance of that type ('private final Log log'). 3. It accepts the component to be wrapped in the constructor. 4. It adds behavior to the existing methods: specifically, it adds a 'prefix' string to messages and checks a boolean flag ('outputMessages') before delegating the core logging functionality.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'LogDisplayWrapper' follows the Decorator pattern structure perfectly. 1. It shares the same type as the object it wraps (it extends 'Log'). 2. It holds a reference to an instance of that type ('private final Log log'). 3. It accepts the component to be wrapped in the constructor. 4. It adds behavior to the existing methods: specifically, it adds a 'prefix' string to messages and checks a boolean flag ('outputMessages') before delegating the core logging functionality.""
	}]
}
```",19.325975
DPD-molgenis_apps-legacy-TaskDecorator.java,decorator,gpt-5,Decorator,95,90,"TaskDecorator wraps a Mapper (via MapperDecorator), keeps the same Mapper interface, and augments add/update/remove by setting the owner and persisting TaskHistory before/after delegating to the wrapped mapper through super. This transparently adds responsibilities without changing the component’s interface. It is not an Adapter (no interface conversion), not a Proxy (primary intent is added behavior, not access control), and not Observer (no subscription/notification mechanism).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""TaskDecorator wraps a Mapper (via MapperDecorator), keeps the same Mapper interface, and augments add/update/remove by setting the owner and persisting TaskHistory before/after delegating to the wrapped mapper through super. This transparently adds responsibilities without changing the component’s interface. It is not an Adapter (no interface conversion), not a Proxy (primary intent is added behavior, not access control), and not Observer (no subscription/notification mechanism).""
    }
  ]
}",20.792908
DPD-molgenis_apps-legacy-TaskDecorator.java,decorator,gemini-3.0-pro,Decorator,98,100,"The class `TaskDecorator` explicitly extends `MapperDecorator` and appears to wrap a `Mapper` component (implied by the constructor passing `generatedMapper` to `super`). It overrides operations (`add`, `update`, `remove`) to inject additional behavior (setting the owner and logging history) before or after delegating the execution to the wrapped object via `super` calls. This is the structural definition of the Decorator pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Decorator"",
		""confidence"": 98,
		""adherence"": 100,
		""reason"": ""The class `TaskDecorator` explicitly extends `MapperDecorator` and appears to wrap a `Mapper` component (implied by the constructor passing `generatedMapper` to `super`). It overrides operations (`add`, `update`, `remove`) to inject additional behavior (setting the owner and logging history) before or after delegating the execution to the wrapped object via `super` calls. This is the structural definition of the Decorator pattern.""
	}]
}
```",17.216826
DPD-fuzzydb-AgeDecorator.java,decorator,gpt-5,Strategy,65,70,"AgeDecorator defines a specific algorithm for converting a BaseAttribute to a String by overriding getValueString. It is likely one of several interchangeable algorithms selected at runtime via the Decorator base type. There is no object wrapping, only polymorphic behavior, aligning with Strategy.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""AgeDecorator defines a specific algorithm for converting a BaseAttribute to a String by overriding getValueString. It is likely one of several interchangeable algorithms selected at runtime via the Decorator base type. There is no object wrapping, only polymorphic behavior, aligning with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 20,
      ""adherence"": 15,
      ""reason"": ""Despite the class name and base class name, the code shows no wrapped component or delegation to a contained component. It does not add responsibilities to a specific object instance; it simply computes a representation, so the GoF Decorator structure is not evident.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""It is plausible the Decorator base class defines a general workflow and relies on subclasses to supply the step getValueString. However, without seeing the base class, this remains speculative and thus only weakly indicated.""
    }
  ]
}",30.795753
DPD-fuzzydb-AgeDecorator.java,decorator,gpt-5,Decorator,20,15,"Despite the class name and base class name, the code shows no wrapped component or delegation to a contained component. It does not add responsibilities to a specific object instance; it simply computes a representation, so the GoF Decorator structure is not evident.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""AgeDecorator defines a specific algorithm for converting a BaseAttribute to a String by overriding getValueString. It is likely one of several interchangeable algorithms selected at runtime via the Decorator base type. There is no object wrapping, only polymorphic behavior, aligning with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 20,
      ""adherence"": 15,
      ""reason"": ""Despite the class name and base class name, the code shows no wrapped component or delegation to a contained component. It does not add responsibilities to a specific object instance; it simply computes a representation, so the GoF Decorator structure is not evident.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""It is plausible the Decorator base class defines a general workflow and relies on subclasses to supply the step getValueString. However, without seeing the base class, this remains speculative and thus only weakly indicated.""
    }
  ]
}",30.795753
DPD-fuzzydb-AgeDecorator.java,decorator,gpt-5,Template Method,35,30,"It is plausible the Decorator base class defines a general workflow and relies on subclasses to supply the step getValueString. However, without seeing the base class, this remains speculative and thus only weakly indicated.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""AgeDecorator defines a specific algorithm for converting a BaseAttribute to a String by overriding getValueString. It is likely one of several interchangeable algorithms selected at runtime via the Decorator base type. There is no object wrapping, only polymorphic behavior, aligning with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 20,
      ""adherence"": 15,
      ""reason"": ""Despite the class name and base class name, the code shows no wrapped component or delegation to a contained component. It does not add responsibilities to a specific object instance; it simply computes a representation, so the GoF Decorator structure is not evident.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 35,
      ""adherence"": 30,
      ""reason"": ""It is plausible the Decorator base class defines a general workflow and relies on subclasses to supply the step getValueString. However, without seeing the base class, this remains speculative and thus only weakly indicated.""
    }
  ]
}",30.795753
DPD-fuzzydb-AgeDecorator.java,decorator,gemini-3.0-pro,Strategy,95,100,"The class encapsulates a specific algorithm (calculating age from a timestamp) inside the 'getValueString' method. By extending 'Decorator' (acting as the Strategy interface/abstract class), this logic can be swapped interchangeably with other formatting strategies. The data ('BaseAttribute') is passed as an argument to the method, which is characteristic of the Strategy pattern, keeping the logic stateless and reusable.","Here is the analysis of the provided source code.

```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 95,
      ""adherence"": 100,
      ""reason"": ""The class encapsulates a specific algorithm (calculating age from a timestamp) inside the 'getValueString' method. By extending 'Decorator' (acting as the Strategy interface/abstract class), this logic can be swapped interchangeably with other formatting strategies. The data ('BaseAttribute') is passed as an argument to the method, which is characteristic of the Strategy pattern, keeping the logic stateless and reusable.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 40,
      ""adherence"": 10,
      ""reason"": ""The class is explicitly named 'AgeDecorator' and extends a class named 'Decorator', indicating the developer's intent to apply the Decorator pattern. However, structurally, it fails to meet the GoF pattern requirements (the 'missing part' noted in the prompt). It does not wrap/contain an instance of the component (Composition) nor does it strictly mirror the component's interface to add stateful behavior. Instead, it relies on method arguments, behaving functionally like a Strategy or Formatter.""
    }
  ]
}
```",62.143832
DPD-fuzzydb-AgeDecorator.java,decorator,gemini-3.0-pro,Decorator,40,10,"The class is explicitly named 'AgeDecorator' and extends a class named 'Decorator', indicating the developer's intent to apply the Decorator pattern. However, structurally, it fails to meet the GoF pattern requirements (the 'missing part' noted in the prompt). It does not wrap/contain an instance of the component (Composition) nor does it strictly mirror the component's interface to add stateful behavior. Instead, it relies on method arguments, behaving functionally like a Strategy or Formatter.","Here is the analysis of the provided source code.

```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 95,
      ""adherence"": 100,
      ""reason"": ""The class encapsulates a specific algorithm (calculating age from a timestamp) inside the 'getValueString' method. By extending 'Decorator' (acting as the Strategy interface/abstract class), this logic can be swapped interchangeably with other formatting strategies. The data ('BaseAttribute') is passed as an argument to the method, which is characteristic of the Strategy pattern, keeping the logic stateless and reusable.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 40,
      ""adherence"": 10,
      ""reason"": ""The class is explicitly named 'AgeDecorator' and extends a class named 'Decorator', indicating the developer's intent to apply the Decorator pattern. However, structurally, it fails to meet the GoF pattern requirements (the 'missing part' noted in the prompt). It does not wrap/contain an instance of the component (Composition) nor does it strictly mirror the component's interface to add stateful behavior. Instead, it relies on method arguments, behaving functionally like a Strategy or Formatter.""
    }
  ]
}
```",62.143832
PMART-Azureus-CategoryListener.java,observer,gpt-5,Observer,70,60,"CategoryListener defines callback methods for change notifications (downloadManagerAdded/Removed) consistent with the Observer pattern, where Category would act as the subject and listeners as observers. However, the provided snippet lacks the subject-side mechanics (e.g., add/remove listener methods, storage of listeners, and notification logic), so adherence cannot be fully confirmed.","{""design_patterns"": [{""pattern"": ""Observer"", ""confidence"": 70, ""adherence"": 60, ""reason"": ""CategoryListener defines callback methods for change notifications (downloadManagerAdded/Removed) consistent with the Observer pattern, where Category would act as the subject and listeners as observers. However, the provided snippet lacks the subject-side mechanics (e.g., add/remove listener methods, storage of listeners, and notification logic), so adherence cannot be fully confirmed.""}]}",12.957391
PMART-Azureus-CategoryListener.java,observer,gemini-3.0-pro,Observer,95,100,"The code defines an interface 'CategoryListener' with callback methods ('downloadManagerAdded', 'downloadManagerRemoved'). This structure is the standard definition of the Observer participant (often called 'Listener' in Java) within the Observer design pattern. It establishes a contract for objects that wish to be notified of specific state changes or events occurring in a Subject (in this case, the 'Category' class).","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The code defines an interface 'CategoryListener' with callback methods ('downloadManagerAdded', 'downloadManagerRemoved'). This structure is the standard definition of the Observer participant (often called 'Listener' in Java) within the Observer design pattern. It establishes a contract for objects that wish to be notified of specific state changes or events occurring in a Subject (in this case, the 'Category' class).""
	}]
}
```",13.060462
DPD-jge3d-Observer.java,observer,gpt-5,Observer,62,35,"Defines an Observer-like interface with an update() callback intended for notification, consistent with the Observer pattern. However, there is no Subject/Observable, registration (attach/detach), or notification mechanism shown, and the update method carries no context/data, so the full pattern implementation cannot be confirmed.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 62,
      ""adherence"": 35,
      ""reason"": ""Defines an Observer-like interface with an update() callback intended for notification, consistent with the Observer pattern. However, there is no Subject/Observable, registration (attach/detach), or notification mechanism shown, and the update method carries no context/data, so the full pattern implementation cannot be confirmed.""
    }
  ]
}",12.649353
DPD-jge3d-Observer.java,observer,gemini-3.0-pro,Observer,98,100,"The code defines an interface named `EntityListObserver` containing a single method `update()`. This strictly follows the definition of the Observer participant in the Observer design pattern, establishing a contract for objects that need to be notified of changes.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 98,
		""adherence"": 100,
		""reason"": ""The code defines an interface named `EntityListObserver` containing a single method `update()`. This strictly follows the definition of the Observer participant in the Observer design pattern, establishing a contract for objects that need to be notified of changes.""
	}]
}
```",24.474442
DPD-smsc-server-StatisticsObserver.java,observer,gpt-5,Observer,68,55,"The interface defines a set of event notification callbacks (notifyBind, notifyBindFail, notifyOpenConnection, etc.), which is characteristic of the Observer/Listener style where a subject would notify observers about state changes or events. However, the snippet only shows the observer interface without the corresponding subject (no registration/unregistration or notify mechanisms shown), so full adherence to the Observer pattern cannot be confirmed from this code alone.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 68,
      ""adherence"": 55,
      ""reason"": ""The interface defines a set of event notification callbacks (notifyBind, notifyBindFail, notifyOpenConnection, etc.), which is characteristic of the Observer/Listener style where a subject would notify observers about state changes or events. However, the snippet only shows the observer interface without the corresponding subject (no registration/unregistration or notify mechanisms shown), so full adherence to the Observer pattern cannot be confirmed from this code alone.""
    }
  ]
}",14.551334
DPD-smsc-server-StatisticsObserver.java,observer,gemini-3.0-pro,Observer,100,100,"The code defines an interface named 'StatisticsObserver' containing multiple void methods prefixed with 'notify' (e.g., 'notifyBind', 'notifyMessageReceived'). This structure corresponds exactly to the Observer participant in the Observer design pattern, defining a contract for objects that subscribe to and receive specific event notifications from a Subject.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The code defines an interface named 'StatisticsObserver' containing multiple void methods prefixed with 'notify' (e.g., 'notifyBind', 'notifyMessageReceived'). This structure corresponds exactly to the Observer participant in the Observer design pattern, defining a contract for objects that subscribe to and receive specific event notifications from a Subject.""
	}]
}
```",16.39675
PMART-Xalan-PrintTraceListener.java,observer,gpt-5,Observer,88,90,"PrintTraceListener implements the TraceListener interface and reacts to events (TracerEvent, SelectionEvent, GenerateEvent) via callback methods (trace, selected, generated). This is a classic listener/observer setup where a subject (not shown here, e.g., a transformer/tracer) notifies registered observers. The class holds no control over event dispatching, only responds to notifications, and uses event objects to carry state—typical Observer pattern characteristics.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 88,
      ""adherence"": 90,
      ""reason"": ""PrintTraceListener implements the TraceListener interface and reacts to events (TracerEvent, SelectionEvent, GenerateEvent) via callback methods (trace, selected, generated). This is a classic listener/observer setup where a subject (not shown here, e.g., a transformer/tracer) notifies registered observers. The class holds no control over event dispatching, only responds to notifications, and uses event objects to carry state—typical Observer pattern characteristics.""
    }
  ]
}",14.530223
PMART-Xalan-PrintTraceListener.java,observer,gemini-3.0-pro,Observer,95,90,"The class 'PrintTraceListener' implements the 'TraceListener' interface, identifying it as a Concrete Observer (or Subscriber). It defines specific update methods ('trace', 'selected', 'generated') that accept 'Event' objects (TracerEvent, SelectionEvent, GenerateEvent). This structure allows the class to be notified of changes or specific points of execution by a Subject (the XSLT processor) and handle them asynchronously, which is the core definition of the Observer pattern in Java event handling.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 90,
		""reason"": ""The class 'PrintTraceListener' implements the 'TraceListener' interface, identifying it as a Concrete Observer (or Subscriber). It defines specific update methods ('trace', 'selected', 'generated') that accept 'Event' objects (TracerEvent, SelectionEvent, GenerateEvent). This structure allows the class to be notified of changes or specific points of execution by a Subject (the XSLT processor) and handle them asynchronously, which is the core definition of the Observer pattern in Java event handling.""
	}]
}
```",22.162767
PMART-Azureus-DownloadWillBeRemovedListener.java,observer,gpt-5,Observer,70,50,"The interface defines a listener callback (downloadWillBeRemoved) that is intended to be notified before a download is removed. This matches the Observer pattern where observers (listeners) are notified of subject events. The ability to veto via DownloadRemovalVetoException is a common variant in event/listener systems. However, the subject, registration/deregistration mechanisms, and notification flow are not shown here, so adherence can only be partially confirmed from this snippet.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 70,
      ""adherence"": 50,
      ""reason"": ""The interface defines a listener callback (downloadWillBeRemoved) that is intended to be notified before a download is removed. This matches the Observer pattern where observers (listeners) are notified of subject events. The ability to veto via DownloadRemovalVetoException is a common variant in event/listener systems. However, the subject, registration/deregistration mechanisms, and notification flow are not shown here, so adherence can only be partially confirmed from this snippet.""
    }
  ]
}",17.519029
PMART-Azureus-DownloadWillBeRemovedListener.java,observer,gemini-3.0-pro,Observer,95,100,The code defines an interface with the suffix 'Listener' containing a specific callback method ('downloadWillBeRemoved'). This is the standard Java implementation of the Observer component within the Observer pattern. It defines the contract for an object that wishes to receive notifications/updates from a Subject (the 'Download' object).,"```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The code defines an interface with the suffix 'Listener' containing a specific callback method ('downloadWillBeRemoved'). This is the standard Java implementation of the Observer component within the Observer pattern. It defines the contract for an object that wishes to receive notifications/updates from a Subject (the 'Download' object).""
	}]
}
```",14.734277
DPD-cream-LoggingObserver.java,observer,gpt-5,Observer,93,90,"LoggingObserver implements EventListener and is registered via @JcrOnEvent to receive JCR repository events. The framework notifies onEvent when the subject (JCR observation mechanism) publishes changes, which is a classic observer/subscriber setup.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 93,
      ""adherence"": 90,
      ""reason"": ""LoggingObserver implements EventListener and is registered via @JcrOnEvent to receive JCR repository events. The framework notifies onEvent when the subject (JCR observation mechanism) publishes changes, which is a classic observer/subscriber setup.""
    },
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 87,
      ""adherence"": 95,
      ""reason"": ""The code consumes EventIterator using hasNext() and nextEvent() to traverse events without exposing the underlying collection, which aligns with the Iterator pattern.""
    }
  ]
}",20.039821
DPD-cream-LoggingObserver.java,observer,gpt-5,Iterator,87,95,"The code consumes EventIterator using hasNext() and nextEvent() to traverse events without exposing the underlying collection, which aligns with the Iterator pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 93,
      ""adherence"": 90,
      ""reason"": ""LoggingObserver implements EventListener and is registered via @JcrOnEvent to receive JCR repository events. The framework notifies onEvent when the subject (JCR observation mechanism) publishes changes, which is a classic observer/subscriber setup.""
    },
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 87,
      ""adherence"": 95,
      ""reason"": ""The code consumes EventIterator using hasNext() and nextEvent() to traverse events without exposing the underlying collection, which aligns with the Iterator pattern.""
    }
  ]
}",20.039821
DPD-cream-LoggingObserver.java,observer,gemini-3.0-pro,Observer,100,100,"The class functions as a Concrete Observer. It implements the `EventListener` interface and defines the `onEvent` method to receive updates. The `@JcrOnEvent` annotation acts as the subscription mechanism, registering the class to listen for specific state changes (events like NODE_ADDED, NODE_REMOVED) occurring within the Subject (the Java Content Repository/JCR).","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class functions as a Concrete Observer. It implements the `EventListener` interface and defines the `onEvent` method to receive updates. The `@JcrOnEvent` annotation acts as the subscription mechanism, registering the class to listen for specific state changes (events like NODE_ADDED, NODE_REMOVED) occurring within the Subject (the Java Content Repository/JCR).""
	}]
}
```",19.760157
PMART-PMARt-TitleChangeListener.java,observer,gpt-5,Observer,78,60,"Defines a listener interface (TitleChangeListener extends EventListener) with a callback method (titleChanged(TitleChangeEvent)) to receive change notifications, which aligns with the observer/event-listener pattern. This snippet, however, does not include the subject or registration/unregistration methods, so only part of the pattern is visible.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 78,
      ""adherence"": 60,
      ""reason"": ""Defines a listener interface (TitleChangeListener extends EventListener) with a callback method (titleChanged(TitleChangeEvent)) to receive change notifications, which aligns with the observer/event-listener pattern. This snippet, however, does not include the subject or registration/unregistration methods, so only part of the pattern is visible.""
    }
  ]
}",21.817187
PMART-PMARt-TitleChangeListener.java,observer,gemini-3.0-pro,Observer,100,100,"The code defines an interface `TitleChangeListener` which extends `java.util.EventListener` and contains a callback method `titleChanged` accepting an event object. This is the canonical implementation of the Observer (Subscriber) interface in Java's event-driven architecture, intended to receive notifications from a Subject.","```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 100,
      ""adherence"": 100,
      ""reason"": ""The code defines an interface `TitleChangeListener` which extends `java.util.EventListener` and contains a callback method `titleChanged` accepting an event object. This is the canonical implementation of the Observer (Subscriber) interface in Java's event-driven architecture, intended to receive notifications from a Subject.""
    }
  ]
}
```",14.548394
PMART-Xerces-DtdEventListener.java,observer,gpt-5,Observer,85,70,"DtdEventListener defines a listener interface for DTD-related events emitted by a parser, matching the Observer pattern: the parser (subject) notifies registered listeners (observers) about events like startDtd/endDtd, entityDecls, and attributeDecls. The code shows the Observer role (callbacks) but not the Subject side (attach/detach and notification dispatch), which slightly reduces adherence in this snippet alone.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 70,
      ""reason"": ""DtdEventListener defines a listener interface for DTD-related events emitted by a parser, matching the Observer pattern: the parser (subject) notifies registered listeners (observers) about events like startDtd/endDtd, entityDecls, and attributeDecls. The code shows the Observer role (callbacks) but not the Subject side (attach/detach and notification dispatch), which slightly reduces adherence in this snippet alone.""
    }
  ]
}",19.64538
PMART-Xerces-DtdEventListener.java,observer,gemini-3.0-pro,Observer,100,100,"The code defines an interface `DtdEventListener` which acts as the 'Observer' component in the Observer pattern (commonly referred to as the Listener pattern in Java). It extends `DTDHandler` and defines a series of callback methods (such as `startDtd`, `elementDecl`, and `attributeDecl`). These methods are designed to be invoked by a 'Subject' (in this case, an XML Parser) to notify the listener when specific parsing events occur. The Javadoc explicitly uses terms like 'events are signaled', 'receive notification', and 'callbacks', which are hallmarks of this pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The code defines an interface `DtdEventListener` which acts as the 'Observer' component in the Observer pattern (commonly referred to as the Listener pattern in Java). It extends `DTDHandler` and defines a series of callback methods (such as `startDtd`, `elementDecl`, and `attributeDecl`). These methods are designed to be invoked by a 'Subject' (in this case, an XML Parser) to notify the listener when specific parsing events occur. The Javadoc explicitly uses terms like 'events are signaled', 'receive notification', and 'callbacks', which are hallmarks of this pattern.""
	}]
}
```",18.260003
DPD-JavaDesignPatternExercises-ISubject.java,observer,gpt-5,Observer,93,70,"The ISubject interface defines methods to register, deregister, and notify observers (IObserver), which matches the Subject role in the Observer pattern. However, adherence is not perfect because the code is only an interface (no storage of observers or concrete notify behavior shown), method names are atypical (addSubject/removeSubject instead of addObserver/removeObserver), and there is no indication of what data is pushed/pulled to observers (no update signature or event parameter visible).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 93,
      ""adherence"": 70,
      ""reason"": ""The ISubject interface defines methods to register, deregister, and notify observers (IObserver), which matches the Subject role in the Observer pattern. However, adherence is not perfect because the code is only an interface (no storage of observers or concrete notify behavior shown), method names are atypical (addSubject/removeSubject instead of addObserver/removeObserver), and there is no indication of what data is pushed/pulled to observers (no update signature or event parameter visible).""
    }
  ]
}",10.465498
DPD-JavaDesignPatternExercises-ISubject.java,observer,gemini-3.0-pro,Observer,95,60,"The interface ISubject clearly defines the contract for the Subject participant in the Observer pattern, featuring the three required methods: subscription, unsubscription, and notification. The methods accept an 'IObserver' type, confirming the relationship. However, the adherence score is penalized because the method names are semantically incorrect: 'addSubject' and 'notifySubjects' imply the Subject is managing itself, whereas standard naming would be 'addObserver' and 'notifyObservers'.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 60,
		""reason"": ""The interface ISubject clearly defines the contract for the Subject participant in the Observer pattern, featuring the three required methods: subscription, unsubscription, and notification. The methods accept an 'IObserver' type, confirming the relationship. However, the adherence score is penalized because the method names are semantically incorrect: 'addSubject' and 'notifySubjects' imply the Subject is managing itself, whereas standard naming would be 'addObserver' and 'notifyObservers'.""
	}]
}
```",16.338513
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gpt-5,Observer,90,90,"The class implements the MessageObserver interface and exposes onMessage as a callback that is invoked when a message arrives, fitting the observer pattern where the subject (message source/transport) notifies observers.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""The class implements the MessageObserver interface and exposes onMessage as a callback that is invoked when a message arrives, fitting the observer pattern where the subject (message source/transport) notifies observers.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""onMessage defines the fixed algorithm for fault handling (construct fault message, set exchange state, build and run interceptor chain) while deferring specific steps to abstract hooks isOutboundObserver(), getPhases(), and the overridable initializeInterceptors().""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""It constructs and executes a PhaseInterceptorChain and invokes chain.doIntercept(faultMessage), passing the message through a sequence of interceptors (handlers), which is characteristic of CoR.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The code delegates message creation to exchange.getEndpoint().getBinding().createMessage(faultMessage) instead of instantiating directly, indicating use of a factory method provided by another component (Binding). This class is a client of that factory.""
    }
  ]
}",29.107787
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gpt-5,Template Method,95,95,"onMessage defines the fixed algorithm for fault handling (construct fault message, set exchange state, build and run interceptor chain) while deferring specific steps to abstract hooks isOutboundObserver(), getPhases(), and the overridable initializeInterceptors().","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""The class implements the MessageObserver interface and exposes onMessage as a callback that is invoked when a message arrives, fitting the observer pattern where the subject (message source/transport) notifies observers.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""onMessage defines the fixed algorithm for fault handling (construct fault message, set exchange state, build and run interceptor chain) while deferring specific steps to abstract hooks isOutboundObserver(), getPhases(), and the overridable initializeInterceptors().""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""It constructs and executes a PhaseInterceptorChain and invokes chain.doIntercept(faultMessage), passing the message through a sequence of interceptors (handlers), which is characteristic of CoR.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The code delegates message creation to exchange.getEndpoint().getBinding().createMessage(faultMessage) instead of instantiating directly, indicating use of a factory method provided by another component (Binding). This class is a client of that factory.""
    }
  ]
}",29.107787
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gpt-5,Chain of Responsibility,85,85,"It constructs and executes a PhaseInterceptorChain and invokes chain.doIntercept(faultMessage), passing the message through a sequence of interceptors (handlers), which is characteristic of CoR.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""The class implements the MessageObserver interface and exposes onMessage as a callback that is invoked when a message arrives, fitting the observer pattern where the subject (message source/transport) notifies observers.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""onMessage defines the fixed algorithm for fault handling (construct fault message, set exchange state, build and run interceptor chain) while deferring specific steps to abstract hooks isOutboundObserver(), getPhases(), and the overridable initializeInterceptors().""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""It constructs and executes a PhaseInterceptorChain and invokes chain.doIntercept(faultMessage), passing the message through a sequence of interceptors (handlers), which is characteristic of CoR.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The code delegates message creation to exchange.getEndpoint().getBinding().createMessage(faultMessage) instead of instantiating directly, indicating use of a factory method provided by another component (Binding). This class is a client of that factory.""
    }
  ]
}",29.107787
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gpt-5,Factory Method,60,60,"The code delegates message creation to exchange.getEndpoint().getBinding().createMessage(faultMessage) instead of instantiating directly, indicating use of a factory method provided by another component (Binding). This class is a client of that factory.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""The class implements the MessageObserver interface and exposes onMessage as a callback that is invoked when a message arrives, fitting the observer pattern where the subject (message source/transport) notifies observers.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 95,
      ""adherence"": 95,
      ""reason"": ""onMessage defines the fixed algorithm for fault handling (construct fault message, set exchange state, build and run interceptor chain) while deferring specific steps to abstract hooks isOutboundObserver(), getPhases(), and the overridable initializeInterceptors().""
    },
    {
      ""pattern"": ""Chain of Responsibility"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""It constructs and executes a PhaseInterceptorChain and invokes chain.doIntercept(faultMessage), passing the message through a sequence of interceptors (handlers), which is characteristic of CoR.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""The code delegates message creation to exchange.getEndpoint().getBinding().createMessage(faultMessage) instead of instantiating directly, indicating use of a factory method provided by another component (Binding). This class is a client of that factory.""
    }
  ]
}",29.107787
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gemini-3.0-pro,Observer,100,100,"The class implements the 'MessageObserver' interface and defines the 'onMessage' method. This structure corresponds to the Subscriber participant in the Observer pattern, where 'onMessage' is the update method invoked when the subject triggers an event.","```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements the 'MessageObserver' interface and defines the 'onMessage' method. This structure corresponds to the Subscriber participant in the Observer pattern, where 'onMessage' is the update method invoked when the subject triggers an event.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 100,
			""adherence"": 95,
			""reason"": ""The 'onMessage' method acts as the template method. It defines a fixed algorithm skeleton for handling fault messages (setting contexts, processing the exchange, executing a chain). It defers specific steps of the algorithm to the abstract methods 'getPhases' and 'isOutboundObserver', and provides a hook method 'initializeInterceptors' for subclasses to extend.""
		}
	]
}
```",21.078694
DPD-cxf-AbstractFaultChainInitiatorObserver.java,observer,gemini-3.0-pro,Template Method,100,95,"The 'onMessage' method acts as the template method. It defines a fixed algorithm skeleton for handling fault messages (setting contexts, processing the exchange, executing a chain). It defers specific steps of the algorithm to the abstract methods 'getPhases' and 'isOutboundObserver', and provides a hook method 'initializeInterceptors' for subclasses to extend.","```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements the 'MessageObserver' interface and defines the 'onMessage' method. This structure corresponds to the Subscriber participant in the Observer pattern, where 'onMessage' is the update method invoked when the subject triggers an event.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 100,
			""adherence"": 95,
			""reason"": ""The 'onMessage' method acts as the template method. It defines a fixed algorithm skeleton for handling fault messages (setting contexts, processing the exchange, executing a chain). It defers specific steps of the algorithm to the abstract methods 'getPhases' and 'isOutboundObserver', and provides a hook method 'initializeInterceptors' for subclasses to extend.""
		}
	]
}
```",21.078694
DPD-JavaDesignPatternExercises-IObserver.java,observer,gpt-5,Observer,70,55,"The interface IObserver with a single update(ISubject s) method matches the canonical Observer role, referencing a Subject type (ISubject). This suggests an Observer pattern skeleton. However, the snippet lacks the Subject interface/implementation (attach/detach/notify) and any concrete observers/subjects, so full adherence to the pattern cannot be verified.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 70,
      ""adherence"": 55,
      ""reason"": ""The interface IObserver with a single update(ISubject s) method matches the canonical Observer role, referencing a Subject type (ISubject). This suggests an Observer pattern skeleton. However, the snippet lacks the Subject interface/implementation (attach/detach/notify) and any concrete observers/subjects, so full adherence to the pattern cannot be verified.""
    }
  ]
}",8.797843
DPD-JavaDesignPatternExercises-IObserver.java,observer,gemini-3.0-pro,Observer,95,100,"The provided code defines an interface 'IObserver' containing an 'update' method that accepts an 'ISubject' as an argument. This structure strictly adheres to the definition of the Observer component within the Observer design pattern, establishing the necessary contract for a Subject to notify subscribers.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The provided code defines an interface 'IObserver' containing an 'update' method that accepts an 'ISubject' as an argument. This structure strictly adheres to the definition of the Observer component within the Observer design pattern, establishing the necessary contract for a Subject to notify subscribers.""
	}]
}
```",26.508029
DPD-brightroom-AppHistoryObserver.java,observer,gpt-5,Observer,95,90,"The class both observes and registers observers. AppHistoryObserver implements HistoryObserver and reacts to history/navigation events fired by HistoryHandler (onPlaceChange, onHistoryChanged, onAppStarted). It also registers multiple event handlers on an EventBus (RoomListEntrySelectedEvent, ActionEvent with ActionNames.BACK, GauthEvent). Handlers are decoupled from publishers and managed via HandlerRegistration/HandlerRegistrationCollection, which is characteristic of the observer (publisher-subscriber) pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class both observes and registers observers. AppHistoryObserver implements HistoryObserver and reacts to history/navigation events fired by HistoryHandler (onPlaceChange, onHistoryChanged, onAppStarted). It also registers multiple event handlers on an EventBus (RoomListEntrySelectedEvent, ActionEvent with ActionNames.BACK, GauthEvent). Handlers are decoupled from publishers and managed via HandlerRegistration/HandlerRegistrationCollection, which is characteristic of the observer (publisher-subscriber) pattern.""
    }
  ]
}",37.86326
DPD-brightroom-AppHistoryObserver.java,observer,gemini-3.0-pro,Observer,100,100,"The class implements the 'HistoryObserver' interface and provides concrete implementations for callback methods like 'onPlaceChange' and 'onHistoryChanged', which are triggered upon state changes in the history system. Additionally, inside the 'bind' method, the class acts as a subscriber by registering specific handlers (anonymous inner classes) to the 'EventBus' to listen for and react to events such as 'RoomListEntrySelectedEvent' and 'ActionEvent'. This fits the definition of the Observer pattern (specifically the Publisher-Subscriber variation).","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class implements the 'HistoryObserver' interface and provides concrete implementations for callback methods like 'onPlaceChange' and 'onHistoryChanged', which are triggered upon state changes in the history system. Additionally, inside the 'bind' method, the class acts as a subscriber by registering specific handlers (anonymous inner classes) to the 'EventBus' to listen for and react to events such as 'RoomListEntrySelectedEvent' and 'ActionEvent'. This fits the definition of the Observer pattern (specifically the Publisher-Subscriber variation).""
	}]
}
```",19.126581
PMART-Ant-BuildListener.java,observer,gpt-5,Observer,95,88,"BuildListener defines an observer interface (extending EventListener) with callbacks like buildStarted/Finished, targetStarted/Finished, taskStarted/Finished, and messageLogged. The Javadoc references Project#addBuildListener(BuildListener), indicating a Subject that registers observers and notifies them with BuildEvent objects (push model). While the Subject implementation and remove/notify logic are not shown in this snippet, the structure strongly matches the Observer pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 95,
      ""adherence"": 88,
      ""reason"": ""BuildListener defines an observer interface (extending EventListener) with callbacks like buildStarted/Finished, targetStarted/Finished, taskStarted/Finished, and messageLogged. The Javadoc references Project#addBuildListener(BuildListener), indicating a Subject that registers observers and notifies them with BuildEvent objects (push model). While the Subject implementation and remove/notify logic are not shown in this snippet, the structure strongly matches the Observer pattern.""
    }
  ]
}",13.408548
PMART-Ant-BuildListener.java,observer,gemini-3.0-pro,Observer,100,100,"The interface 'BuildListener' extends 'java.util.EventListener' and defines specific callback methods (e.g., 'buildStarted', 'taskFinished') that accept an event object ('BuildEvent'). This is the distinct signature of the Observer pattern (specifically the Observer/Subscriber interface role). The Javadoc also references a registration mechanism ('addBuildListener'), confirming that the implementing classes are intended to subscribe to a Subject to receive notifications.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The interface 'BuildListener' extends 'java.util.EventListener' and defines specific callback methods (e.g., 'buildStarted', 'taskFinished') that accept an event object ('BuildEvent'). This is the distinct signature of the Observer pattern (specifically the Observer/Subscriber interface role). The Javadoc also references a registration mechanism ('addBuildListener'), confirming that the implementing classes are intended to subscribe to a Subject to receive notifications.""
	}]
}
```",16.134061
DPD-UK-Ejemplos-Observer.java,observer,gpt-5,Observer,90,45,"Defines an Observer interface with a single update(Object) callback, which matches the observer's role of receiving notifications. However, there is no Subject/Observable, no attach/detach registration methods, and no notify mechanism shown. The use of a raw Object for the update payload also indicates a loosely typed, partial implementation.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 45,
      ""reason"": ""Defines an Observer interface with a single update(Object) callback, which matches the observer's role of receiving notifications. However, there is no Subject/Observable, no attach/detach registration methods, and no notify mechanism shown. The use of a raw Object for the update payload also indicates a loosely typed, partial implementation.""
    }
  ]
}",13.347761
DPD-UK-Ejemplos-Observer.java,observer,gemini-3.0-pro,Observer,95,20,"The code defines an interface specifically named 'Observer' containing an 'update' method that accepts an object (likely the state or the subject), which matches the standard definition of the Observer component in this pattern. However, adherence is low because the implementation is incomplete: the 'Subject' (or Observable) component, the mechanism for attaching/detaching observers, and the logic for triggering notifications are completely missing.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 20,
		""reason"": ""The code defines an interface specifically named 'Observer' containing an 'update' method that accepts an object (likely the state or the subject), which matches the standard definition of the Observer component in this pattern. However, adherence is low because the implementation is incomplete: the 'Subject' (or Observable) component, the mechanism for attaching/detaching observers, and the logic for triggering notifications are completely missing.""
	}]
}
```",18.630233
PMART-PMARt-DatasetChangeListener.java,observer,gpt-5,Observer,90,78,"Defines a listener interface (DatasetChangeListener extends EventListener) with a callback method (datasetChanged(DatasetChangeEvent)) to receive notifications when a dataset changes. The use of an event object indicates a push-style update typical of Observer. While the subject/registration methods are not shown here, this interface clearly represents the observer side of the pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 90,
      ""adherence"": 78,
      ""reason"": ""Defines a listener interface (DatasetChangeListener extends EventListener) with a callback method (datasetChanged(DatasetChangeEvent)) to receive notifications when a dataset changes. The use of an event object indicates a push-style update typical of Observer. While the subject/registration methods are not shown here, this interface clearly represents the observer side of the pattern.""
    }
  ]
}",12.003991
PMART-PMARt-DatasetChangeListener.java,observer,gemini-3.0-pro,Observer,100,100,"The code defines an interface 'DatasetChangeListener' which extends 'java.util.EventListener' and declares a callback method 'datasetChanged' accepting a specific event object. This is the canonical implementation of the Observer participant (specifically the Subscriber interface) within the Java Event model, allowing objects to subscribe to and receive notifications from a Subject (the Dataset).","```json
{
    ""design_patterns"": [
        {
            ""pattern"": ""Observer"",
            ""confidence"": 100,
            ""adherence"": 100,
            ""reason"": ""The code defines an interface 'DatasetChangeListener' which extends 'java.util.EventListener' and declares a callback method 'datasetChanged' accepting a specific event object. This is the canonical implementation of the Observer participant (specifically the Subscriber interface) within the Java Event model, allowing objects to subscribe to and receive notifications from a Subject (the Dataset).""
        }
    ]
}
```",17.571981
DPD-arquillian_deprecated-ObserverImpl.java,observer,gpt-5,Observer,95,90,"ObserverImpl wraps a target and an annotated observer method, implements ObserverMethod, determines the observed event type via the first parameter (getType), and invokes the observer when an event is published (invoke). It orders observers by @Observes(precedence) and returns whether the invocation occurred, which is typical of an event bus/observer system. Although the subject/event dispatcher is not shown here, this class is a concrete observer participant.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""ObserverImpl wraps a target and an annotated observer method, implements ObserverMethod, determines the observed event type via the first parameter (getType), and invokes the observer when an event is published (invoke). It orders observers by @Observes(precedence) and returns whether the invocation occurred, which is typical of an event bus/observer system. Although the subject/event dispatcher is not shown here, this class is a concrete observer participant.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 70,
      ""reason"": ""The class adapts an arbitrary target object and a reflective Method into the ObserverMethod interface. It translates invoke(manager, event) into a reflective call on the target with resolved arguments, effectively adapting the method’s signature/annotation-based contract to the ObserverMethod protocol.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""resolveArguments pulls dependencies for non-event parameters at call time via manager.resolve(argumentType), which centralizes lookup of required services/resources. This pull-based resolution through a Manager is characteristic of the Service Locator pattern rather than push-based dependency injection.""
    }
  ]
}",33.236368
DPD-arquillian_deprecated-ObserverImpl.java,observer,gpt-5,Adapter,68,70,"The class adapts an arbitrary target object and a reflective Method into the ObserverMethod interface. It translates invoke(manager, event) into a reflective call on the target with resolved arguments, effectively adapting the method’s signature/annotation-based contract to the ObserverMethod protocol.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""ObserverImpl wraps a target and an annotated observer method, implements ObserverMethod, determines the observed event type via the first parameter (getType), and invokes the observer when an event is published (invoke). It orders observers by @Observes(precedence) and returns whether the invocation occurred, which is typical of an event bus/observer system. Although the subject/event dispatcher is not shown here, this class is a concrete observer participant.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 70,
      ""reason"": ""The class adapts an arbitrary target object and a reflective Method into the ObserverMethod interface. It translates invoke(manager, event) into a reflective call on the target with resolved arguments, effectively adapting the method’s signature/annotation-based contract to the ObserverMethod protocol.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""resolveArguments pulls dependencies for non-event parameters at call time via manager.resolve(argumentType), which centralizes lookup of required services/resources. This pull-based resolution through a Manager is characteristic of the Service Locator pattern rather than push-based dependency injection.""
    }
  ]
}",33.236368
DPD-arquillian_deprecated-ObserverImpl.java,observer,gpt-5,Service Locator,65,75,"resolveArguments pulls dependencies for non-event parameters at call time via manager.resolve(argumentType), which centralizes lookup of required services/resources. This pull-based resolution through a Manager is characteristic of the Service Locator pattern rather than push-based dependency injection.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""ObserverImpl wraps a target and an annotated observer method, implements ObserverMethod, determines the observed event type via the first parameter (getType), and invokes the observer when an event is published (invoke). It orders observers by @Observes(precedence) and returns whether the invocation occurred, which is typical of an event bus/observer system. Although the subject/event dispatcher is not shown here, this class is a concrete observer participant.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 70,
      ""reason"": ""The class adapts an arbitrary target object and a reflective Method into the ObserverMethod interface. It translates invoke(manager, event) into a reflective call on the target with resolved arguments, effectively adapting the method’s signature/annotation-based contract to the ObserverMethod protocol.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""resolveArguments pulls dependencies for non-event parameters at call time via manager.resolve(argumentType), which centralizes lookup of required services/resources. This pull-based resolution through a Manager is characteristic of the Service Locator pattern rather than push-based dependency injection.""
    }
  ]
}",33.236368
DPD-arquillian_deprecated-ObserverImpl.java,observer,gemini-3.0-pro,Observer,95,90,"The class is explicitly named `ObserverImpl` and implements `ObserverMethod`. It defines behavior to receive and process events (`invoke` method) and handles ordering based on `@Observes` annotations. It acts as the Subscriber/Observer component within an event-driven system, reacting to state changes passed by a Manager.","```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class is explicitly named `ObserverImpl` and implements `ObserverMethod`. It defines behavior to receive and process events (`invoke` method) and handles ordering based on `@Observes` annotations. It acts as the Subscriber/Observer component within an event-driven system, reacting to state changes passed by a Manager.""
		},
		{
			""pattern"": ""Adapter"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The class acts as an Object Adapter. It wraps an arbitrary `target` Object and a `java.lang.reflect.Method` (the adaptees) and makes them conform to the `ObserverMethod` interface. The `invoke` method translates the interface request into a specific reflective call (`method.invoke`) on the wrapped object.""
		},
		{
			""pattern"": ""Static Factory Method"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class provides a public static creation method `of(Object extension, Method observerMethod)` which encapsulates the instantiation logic and hides the package-private constructor.""
		}
	]
}
```",29.367697
DPD-arquillian_deprecated-ObserverImpl.java,observer,gemini-3.0-pro,Adapter,90,95,The class acts as an Object Adapter. It wraps an arbitrary `target` Object and a `java.lang.reflect.Method` (the adaptees) and makes them conform to the `ObserverMethod` interface. The `invoke` method translates the interface request into a specific reflective call (`method.invoke`) on the wrapped object.,"```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class is explicitly named `ObserverImpl` and implements `ObserverMethod`. It defines behavior to receive and process events (`invoke` method) and handles ordering based on `@Observes` annotations. It acts as the Subscriber/Observer component within an event-driven system, reacting to state changes passed by a Manager.""
		},
		{
			""pattern"": ""Adapter"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The class acts as an Object Adapter. It wraps an arbitrary `target` Object and a `java.lang.reflect.Method` (the adaptees) and makes them conform to the `ObserverMethod` interface. The `invoke` method translates the interface request into a specific reflective call (`method.invoke`) on the wrapped object.""
		},
		{
			""pattern"": ""Static Factory Method"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class provides a public static creation method `of(Object extension, Method observerMethod)` which encapsulates the instantiation logic and hides the package-private constructor.""
		}
	]
}
```",29.367697
DPD-arquillian_deprecated-ObserverImpl.java,observer,gemini-3.0-pro,Static Factory Method,100,100,"The class provides a public static creation method `of(Object extension, Method observerMethod)` which encapsulates the instantiation logic and hides the package-private constructor.","```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class is explicitly named `ObserverImpl` and implements `ObserverMethod`. It defines behavior to receive and process events (`invoke` method) and handles ordering based on `@Observes` annotations. It acts as the Subscriber/Observer component within an event-driven system, reacting to state changes passed by a Manager.""
		},
		{
			""pattern"": ""Adapter"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The class acts as an Object Adapter. It wraps an arbitrary `target` Object and a `java.lang.reflect.Method` (the adaptees) and makes them conform to the `ObserverMethod` interface. The `invoke` method translates the interface request into a specific reflective call (`method.invoke`) on the wrapped object.""
		},
		{
			""pattern"": ""Static Factory Method"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class provides a public static creation method `of(Object extension, Method observerMethod)` which encapsulates the instantiation logic and hides the package-private constructor.""
		}
	]
}
```",29.367697
PMART-Azureus-SSDPListener.java,observer,gpt-5,Observer,80,45,"The SSDPListener interface defines event callbacks (rootDiscovered, rootAlive, rootLost) that observers would implement to receive notifications from an SSDP subject, matching the Listener/Observer style. However, the snippet only shows the observer interface; it lacks the subject, registration/unregistration methods, and the notification mechanism, so adherence is only partial based on the provided code.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 80,
      ""adherence"": 45,
      ""reason"": ""The SSDPListener interface defines event callbacks (rootDiscovered, rootAlive, rootLost) that observers would implement to receive notifications from an SSDP subject, matching the Listener/Observer style. However, the snippet only shows the observer interface; it lacks the subject, registration/unregistration methods, and the notification mechanism, so adherence is only partial based on the provided code.""
    }
  ]
}",15.091776
PMART-Azureus-SSDPListener.java,observer,gemini-3.0-pro,Observer,95,100,"The code defines an interface named 'SSDPListener' with methods specifically designed to handle event notifications ('rootDiscovered', 'rootAlive', 'rootLost'). This is the standard definition of the Observer participant (often called a Listener in Java) within the Observer design pattern, intended to define a contract for objects receiving updates from a subject.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The code defines an interface named 'SSDPListener' with methods specifically designed to handle event notifications ('rootDiscovered', 'rootAlive', 'rootLost'). This is the standard definition of the Observer participant (often called a Listener in Java) within the Observer design pattern, intended to define a contract for objects receiving updates from a subject.""
	}]
}
```",21.718726
PMART-PMARt-TrackingAdjustmentListener.java,observer,gpt-5,Observer,85,80,"TrackingAdjustmentListener implements the AdjustmentListener interface and reacts to AdjustmentEvent notifications from an Adjustable (e.g., a scrollbar), which is the subject. This is the classic AWT/Swing listener model of the Observer pattern: the observer (listener) is decoupled from the subject and is notified via a callback method (adjustmentValueChanged). While the registration of the listener with the subject is not shown, the code clearly plays the concrete Observer role.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 80,
      ""reason"": ""TrackingAdjustmentListener implements the AdjustmentListener interface and reacts to AdjustmentEvent notifications from an Adjustable (e.g., a scrollbar), which is the subject. This is the classic AWT/Swing listener model of the Observer pattern: the observer (listener) is decoupled from the subject and is notified via a callback method (adjustmentValueChanged). While the registration of the listener with the subject is not shown, the code clearly plays the concrete Observer role.""
    }
  ]
}",26.350563
PMART-PMARt-TrackingAdjustmentListener.java,observer,gemini-3.0-pro,Observer,100,100,"The class implements the 'AdjustmentListener' interface, which is a standard Observer interface within the Java AWT event model. The 'adjustmentValueChanged' method functions as the 'update' method, which is automatically called when the 'Subject' (an Adjustable object, like a scrollbar) changes its state. This allows the class to react to changes in another object, fulfilling the core definition of the Observer pattern.","```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 100,
      ""adherence"": 100,
      ""reason"": ""The class implements the 'AdjustmentListener' interface, which is a standard Observer interface within the Java AWT event model. The 'adjustmentValueChanged' method functions as the 'update' method, which is automatically called when the 'Subject' (an Adjustable object, like a scrollbar) changes its state. This allows the class to react to changes in another object, fulfilling the core definition of the Observer pattern.""
    }
  ]
}
```",14.564049
PMART-Azureus-WizardListener.java,observer,gpt-5,Observer,55,45,"The presence of a Listener interface with a callback method (closed()) suggests an event-listener setup typical of the Observer pattern in UI code. However, this snippet alone only defines the observer interface; it does not show the subject, registration/unregistration methods, or notification logic. It also lacks an event object or source parameter, which are common in robust observer implementations. Therefore, identification is tentative and adherence appears partial based on the provided code.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The presence of a Listener interface with a callback method (closed()) suggests an event-listener setup typical of the Observer pattern in UI code. However, this snippet alone only defines the observer interface; it does not show the subject, registration/unregistration methods, or notification logic. It also lacks an event object or source parameter, which are common in robust observer implementations. Therefore, identification is tentative and adherence appears partial based on the provided code.""
    }
  ]
}",22.802903
PMART-Azureus-WizardListener.java,observer,gemini-3.0-pro,Observer,98,100,"The code defines an interface named 'WizardListener' with a specific callback method 'closed()'. In Java UI frameworks (indicated by the SWT package), 'Listeners' are the standard implementation of the Observer participant in the Observer pattern. This interface defines the contract for objects that wish to be notified when the 'Subject' (the Wizard) triggers the specific event (closing).","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 98,
		""adherence"": 100,
		""reason"": ""The code defines an interface named 'WizardListener' with a specific callback method 'closed()'. In Java UI frameworks (indicated by the SWT package), 'Listeners' are the standard implementation of the Observer participant in the Observer pattern. This interface defines the contract for objects that wish to be notified when the 'Subject' (the Wizard) triggers the specific event (closing).""
	}]
}
```",16.162533
DPD-pcgen-svn-ShowMessageGuiObserver.java,observer,gpt-5,Observer,96,90,"The class implements java.util.Observer and overrides update(Observable, Object) to react to notifications from an Observable. It processes the notification payload (MessageWrapper) and updates the GUI accordingly. This is a direct use of Java’s built-in Observer/Observable mechanism, which models the GoF Observer pattern. The subject (Observable) is not shown here, but the observer role is correctly implemented.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Observer"",
      ""confidence"": 96,
      ""adherence"": 90,
      ""reason"": ""The class implements java.util.Observer and overrides update(Observable, Object) to react to notifications from an Observable. It processes the notification payload (MessageWrapper) and updates the GUI accordingly. This is a direct use of Java’s built-in Observer/Observable mechanism, which models the GoF Observer pattern. The subject (Observable) is not shown here, but the observer role is correctly implemented.""
    }
  ]
}",15.80145
DPD-pcgen-svn-ShowMessageGuiObserver.java,observer,gemini-3.0-pro,Observer,100,100,"The class explicitly implements the 'java.util.Observer' interface and overrides the 'update' method. It contains the logic to react to notifications (specifically 'MessageWrapper' objects) sent by an 'Observable' subject, which is the standard implementation of the Concrete Observer participant in Java.","```json
{
	""design_patterns"": [{
		""pattern"": ""Observer"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class explicitly implements the 'java.util.Observer' interface and overrides the 'update' method. It contains the logic to react to notifications (specifically 'MessageWrapper' objects) sent by an 'Observable' subject, which is the standard implementation of the Concrete Observer participant in Java.""
	}]
}
```",13.421934
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gpt-5,Iterator,90,85,"The class exposes traversal over its elements via iterator(), delegating to enumerate().iterator(). The commented-out custom Iterator further confirms intent to provide sequential access independent of the underlying representation.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 90,
      ""adherence"": 85,
      ""reason"": ""The class exposes traversal over its elements via iterator(), delegating to enumerate().iterator(). The commented-out custom Iterator further confirms intent to provide sequential access independent of the underlying representation.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 70,
      ""adherence"": 75,
      ""reason"": ""The superclass TypeSet likely defines the overall algorithm for operations like intersection and calls subclass hooks. This class overrides specialCasesIntersectedWith(TypeSet other) to supply subclass-specific steps within a fixed algorithm structure, consistent with the Template Method pattern.""
    },
    {
      ""pattern"": ""Lazy Initialization"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The enumeration of members is created on first use and cached in fEnumCache within enumerate(). Subsequent calls reuse the cached value, demonstrating lazy computation with memoization.""
    }
  ]
}",48.70527
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gpt-5,Template Method,70,75,"The superclass TypeSet likely defines the overall algorithm for operations like intersection and calls subclass hooks. This class overrides specialCasesIntersectedWith(TypeSet other) to supply subclass-specific steps within a fixed algorithm structure, consistent with the Template Method pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 90,
      ""adherence"": 85,
      ""reason"": ""The class exposes traversal over its elements via iterator(), delegating to enumerate().iterator(). The commented-out custom Iterator further confirms intent to provide sequential access independent of the underlying representation.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 70,
      ""adherence"": 75,
      ""reason"": ""The superclass TypeSet likely defines the overall algorithm for operations like intersection and calls subclass hooks. This class overrides specialCasesIntersectedWith(TypeSet other) to supply subclass-specific steps within a fixed algorithm structure, consistent with the Template Method pattern.""
    },
    {
      ""pattern"": ""Lazy Initialization"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The enumeration of members is created on first use and cached in fEnumCache within enumerate(). Subsequent calls reuse the cached value, demonstrating lazy computation with memoization.""
    }
  ]
}",48.70527
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gpt-5,Lazy Initialization,85,90,"The enumeration of members is created on first use and cached in fEnumCache within enumerate(). Subsequent calls reuse the cached value, demonstrating lazy computation with memoization.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 90,
      ""adherence"": 85,
      ""reason"": ""The class exposes traversal over its elements via iterator(), delegating to enumerate().iterator(). The commented-out custom Iterator further confirms intent to provide sequential access independent of the underlying representation.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 70,
      ""adherence"": 75,
      ""reason"": ""The superclass TypeSet likely defines the overall algorithm for operations like intersection and calls subclass hooks. This class overrides specialCasesIntersectedWith(TypeSet other) to supply subclass-specific steps within a fixed algorithm structure, consistent with the Template Method pattern.""
    },
    {
      ""pattern"": ""Lazy Initialization"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The enumeration of members is created on first use and cached in fEnumCache within enumerate(). Subsequent calls reuse the cached value, demonstrating lazy computation with memoization.""
    }
  ]
}",48.70527
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gemini-3.0-pro,Iterator,100,100,The class implements an `iterator()` method which returns a `java.util.Iterator`. This allows external clients to traverse the collection of types represented by this set without exposing the internal complexity of how the types are calculated or stored (delegating to `enumerate().iterator()`).,"```json
{
	""design_patterns"": [
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements an `iterator()` method which returns a `java.util.Iterator`. This allows external clients to traverse the collection of types represented by this set without exposing the internal complexity of how the types are calculated or stored (delegating to `enumerate().iterator()`).""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the protected method `specialCasesIntersectedWith(TypeSet other)`. The naming convention and visibility suggest that the abstract superclass `TypeSet` contains a public template method (likely `intersectedWith`) that defines the skeleton of the operation and calls this hook method for subclass-specific implementation details.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `enumerate()` method utilizes the `fEnumCache` field to store the result of an expensive calculation (generating all supertypes). The calculation is only performed if `fEnumCache` is null, deferring the cost until the data is actually requested.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 85,
			""adherence"": 60,
			""reason"": ""The class contains a `makeClone()` method intended to create a copy of the object. Although the current implementation returns `this` (likely an optimization for immutable objects), it satisfies the interface and intent of the Prototype pattern.""
		}
	]
}
```",39.507427
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gemini-3.0-pro,Template Method,95,100,The class implements the protected method `specialCasesIntersectedWith(TypeSet other)`. The naming convention and visibility suggest that the abstract superclass `TypeSet` contains a public template method (likely `intersectedWith`) that defines the skeleton of the operation and calls this hook method for subclass-specific implementation details.,"```json
{
	""design_patterns"": [
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements an `iterator()` method which returns a `java.util.Iterator`. This allows external clients to traverse the collection of types represented by this set without exposing the internal complexity of how the types are calculated or stored (delegating to `enumerate().iterator()`).""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the protected method `specialCasesIntersectedWith(TypeSet other)`. The naming convention and visibility suggest that the abstract superclass `TypeSet` contains a public template method (likely `intersectedWith`) that defines the skeleton of the operation and calls this hook method for subclass-specific implementation details.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `enumerate()` method utilizes the `fEnumCache` field to store the result of an expensive calculation (generating all supertypes). The calculation is only performed if `fEnumCache` is null, deferring the cost until the data is actually requested.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 85,
			""adherence"": 60,
			""reason"": ""The class contains a `makeClone()` method intended to create a copy of the object. Although the current implementation returns `this` (likely an optimization for immutable objects), it satisfies the interface and intent of the Prototype pattern.""
		}
	]
}
```",39.507427
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gemini-3.0-pro,Lazy Initialization,100,100,"The `enumerate()` method utilizes the `fEnumCache` field to store the result of an expensive calculation (generating all supertypes). The calculation is only performed if `fEnumCache` is null, deferring the cost until the data is actually requested.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements an `iterator()` method which returns a `java.util.Iterator`. This allows external clients to traverse the collection of types represented by this set without exposing the internal complexity of how the types are calculated or stored (delegating to `enumerate().iterator()`).""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the protected method `specialCasesIntersectedWith(TypeSet other)`. The naming convention and visibility suggest that the abstract superclass `TypeSet` contains a public template method (likely `intersectedWith`) that defines the skeleton of the operation and calls this hook method for subclass-specific implementation details.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `enumerate()` method utilizes the `fEnumCache` field to store the result of an expensive calculation (generating all supertypes). The calculation is only performed if `fEnumCache` is null, deferring the cost until the data is actually requested.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 85,
			""adherence"": 60,
			""reason"": ""The class contains a `makeClone()` method intended to create a copy of the object. Although the current implementation returns `this` (likely an optimization for immutable objects), it satisfies the interface and intent of the Prototype pattern.""
		}
	]
}
```",39.507427
PMART-Eclipse-SuperTypesOfSingleton.java,singleton,gemini-3.0-pro,Prototype,85,60,"The class contains a `makeClone()` method intended to create a copy of the object. Although the current implementation returns `this` (likely an optimization for immutable objects), it satisfies the interface and intent of the Prototype pattern.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Iterator"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements an `iterator()` method which returns a `java.util.Iterator`. This allows external clients to traverse the collection of types represented by this set without exposing the internal complexity of how the types are calculated or stored (delegating to `enumerate().iterator()`).""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class implements the protected method `specialCasesIntersectedWith(TypeSet other)`. The naming convention and visibility suggest that the abstract superclass `TypeSet` contains a public template method (likely `intersectedWith`) that defines the skeleton of the operation and calls this hook method for subclass-specific implementation details.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `enumerate()` method utilizes the `fEnumCache` field to store the result of an expensive calculation (generating all supertypes). The calculation is only performed if `fEnumCache` is null, deferring the cost until the data is actually requested.""
		},
		{
			""pattern"": ""Prototype"",
			""confidence"": 85,
			""adherence"": 60,
			""reason"": ""The class contains a `makeClone()` method intended to create a copy of the object. Although the current implementation returns `this` (likely an optimization for immutable objects), it satisfies the interface and intent of the Prototype pattern.""
		}
	]
}
```",39.507427
PMART-PMARt-AlphaSingleton.java,singleton,gpt-5,Singleton,100,88,"Uses a private constructor and a private static final instance with a public static accessor (getInstance), implementing an eager-initialized, classloader-safe Singleton. However, it lacks defenses against breaking the Singleton via serialization (no readResolve) and reflection, and the class is not final (though the private constructor already prevents subclassing).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 100,
      ""adherence"": 88,
      ""reason"": ""Uses a private constructor and a private static final instance with a public static accessor (getInstance), implementing an eager-initialized, classloader-safe Singleton. However, it lacks defenses against breaking the Singleton via serialization (no readResolve) and reflection, and the class is not final (though the private constructor already prevents subclassing).""
    }
  ]
}",13.907127
PMART-PMARt-AlphaSingleton.java,singleton,gemini-3.0-pro,Singleton,100,100,The class implements the Singleton pattern using the eager initialization approach. It fulfills all requirements: 1) A private static final variable 'INSTANCE' ensures only one instance exists. 2) The private constructor prevents external instantiation. 3) The public static method 'getInstance' provides a global point of access to the instance.,"```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 100,
      ""adherence"": 100,
      ""reason"": ""The class implements the Singleton pattern using the eager initialization approach. It fulfills all requirements: 1) A private static final variable 'INSTANCE' ensures only one instance exists. 2) The private constructor prevents external instantiation. 3) The public static method 'getInstance' provides a global point of access to the instance.""
    }
  ]
}
```",10.281066
PMART-PMARt-ScalaSingleton.java,singleton,gpt-5,None,0,0,No pattern detected or parse error,"{""design_patterns"": []}",16.443078
PMART-PMARt-ScalaSingleton.java,singleton,gemini-3.0-pro,None,0,0,No pattern detected or parse error,"```json
{
	""design_patterns"": []
}
```",26.269993
PMART-PMARt-ReloaderSingleton.java,singleton,gpt-5,Strategy,62,58,"ReloaderSingleton holds a reference to a Reloader and delegates reload() to it; clients can register different Reloader implementations at runtime via register(), making the behavior interchangeable—hallmarks of the Strategy pattern. Deviations: the 'context' is a global static holder (not instance-bound), no default/null-object strategy, and no thread-safety or lifecycle management. Despite the class name, this is not a true Singleton (it exposes no single instance of itself).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 62,
      ""adherence"": 58,
      ""reason"": ""ReloaderSingleton holds a reference to a Reloader and delegates reload() to it; clients can register different Reloader implementations at runtime via register(), making the behavior interchangeable—hallmarks of the Strategy pattern. Deviations: the 'context' is a global static holder (not instance-bound), no default/null-object strategy, and no thread-safety or lifecycle management. Despite the class name, this is not a true Singleton (it exposes no single instance of itself).""
    }
  ]
}",54.474914
PMART-PMARt-ReloaderSingleton.java,singleton,gemini-3.0-pro,Singleton,90,60,"The class utilizes a private constructor to prevent external instantiation and maintains a static reference to a single instance (field `singleton`). However, the implementation deviates from the strict GoF definition: instead of self-instantiating (lazy loading) and providing a `getInstance` accessor, it relies on an external caller to inject the instance via the `register` method, effectively acting as a static holder or service locator.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 90,
		""adherence"": 60,
		""reason"": ""The class utilizes a private constructor to prevent external instantiation and maintains a static reference to a single instance (field `singleton`). However, the implementation deviates from the strict GoF definition: instead of self-instantiating (lazy loading) and providing a `getInstance` accessor, it relies on an external caller to inject the instance via the `register` method, effectively acting as a static holder or service locator.""
	}]
}
```",23.311528
DPD-AllBinary-Platform-ImageComparisonResultCacheSingleton.java,singleton,gpt-5,Singleton,93,88,"Maintains a single, globally accessible CacheInterface instance via a private static field initialized in a static block, a private constructor to prevent external instantiation, and a public static accessor. The eager static initialization is thread-safe; the only deviation from the textbook form is that getInstance returns the CacheInterface rather than the class itself.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 93,
      ""adherence"": 88,
      ""reason"": ""Maintains a single, globally accessible CacheInterface instance via a private static field initialized in a static block, a private constructor to prevent external instantiation, and a public static accessor. The eager static initialization is thread-safe; the only deviation from the textbook form is that getInstance returns the CacheInterface rather than the class itself.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The cache instance is obtained via CacheInterfaceFactory.getInstance(...) with type and policy inputs, decoupling creation from use. Although this appears to be a static/simple factory rather than a subclass-overridden creator, it follows the factory method intent in this usage.""
    }
  ]
}",43.6122
DPD-AllBinary-Platform-ImageComparisonResultCacheSingleton.java,singleton,gpt-5,Factory Method,65,60,"The cache instance is obtained via CacheInterfaceFactory.getInstance(...) with type and policy inputs, decoupling creation from use. Although this appears to be a static/simple factory rather than a subclass-overridden creator, it follows the factory method intent in this usage.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 93,
      ""adherence"": 88,
      ""reason"": ""Maintains a single, globally accessible CacheInterface instance via a private static field initialized in a static block, a private constructor to prevent external instantiation, and a public static accessor. The eager static initialization is thread-safe; the only deviation from the textbook form is that getInstance returns the CacheInterface rather than the class itself.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The cache instance is obtained via CacheInterfaceFactory.getInstance(...) with type and policy inputs, decoupling creation from use. Although this appears to be a static/simple factory rather than a subclass-overridden creator, it follows the factory method intent in this usage.""
    }
  ]
}",43.6122
DPD-AllBinary-Platform-ImageComparisonResultCacheSingleton.java,singleton,gemini-3.0-pro,Singleton,95,60,"The class explicitly enforces non-instantiability via a private constructor and provides a global point of access (`getInstance`). However, structurally, it acts as a 'Static Wrapper' or 'Holder' for a different type (`CacheInterface`) rather than managing and returning an instance of the class itself, which deviates from the standard GoF implementation where a Singleton returns an instance of its own class.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 95,
		""adherence"": 60,
		""reason"": ""The class explicitly enforces non-instantiability via a private constructor and provides a global point of access (`getInstance`). However, structurally, it acts as a 'Static Wrapper' or 'Holder' for a different type (`CacheInterface`) rather than managing and returning an instance of the class itself, which deviates from the standard GoF implementation where a Singleton returns an instance of its own class.""
	}]
}
```",54.015017
PMART-PMARt-ScalaSingleton$.java,singleton,gpt-5,Singleton,85,55,"The class exposes a single, eagerly initialized global instance via a public static final field (MODULE$), which matches the core intent of the Singleton pattern. The class is final, preventing subclassing. However, the constructor is not private (default visibility), so additional instances can be created with 'new', and there is no getInstance accessor, reducing adherence to the canonical Singleton implementation.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 85,
      ""adherence"": 55,
      ""reason"": ""The class exposes a single, eagerly initialized global instance via a public static final field (MODULE$), which matches the core intent of the Singleton pattern. The class is final, preventing subclassing. However, the constructor is not private (default visibility), so additional instances can be created with 'new', and there is no getInstance accessor, reducing adherence to the canonical Singleton implementation.""
    }
  ]
}",9.298097
PMART-PMARt-ScalaSingleton$.java,singleton,gemini-3.0-pro,Singleton,95,60,"The class implements the Eager Initialization approach of the Singleton pattern by creating a static final instance of itself (`MODULE$`) to serve as a global access point. High confidence is derived from the structure and the context of simulating a Scala `object`. However, adherence is lower because the class fails to define a private constructor. Since no constructor is explicitly defined, Java provides a default public constructor, which allows external classes to create multiple instances, technically violating the uniqueness constraint of the pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 95,
		""adherence"": 60,
		""reason"": ""The class implements the Eager Initialization approach of the Singleton pattern by creating a static final instance of itself (`MODULE$`) to serve as a global access point. High confidence is derived from the structure and the context of simulating a Scala `object`. However, adherence is lower because the class fails to define a private constructor. Since no constructor is explicitly defined, Java provides a default public constructor, which allows external classes to create multiple instances, technically violating the uniqueness constraint of the pattern.""
	}]
}
```",19.045166
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gpt-5,Singleton,95,50,"The class exposes a single static final instance (SINGLETON) and a getInstance() accessor, indicating a Singleton. However, there is no private constructor, so external code can still instantiate the class (default public constructor), which breaks the Singleton guarantee. Eager initialization is thread-safe.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 50,
      ""reason"": ""The class exposes a single static final instance (SINGLETON) and a getInstance() accessor, indicating a Singleton. However, there is no private constructor, so external code can still instantiate the class (default public constructor), which breaks the Singleton guarantee. Eager initialization is thread-safe.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 80,
      ""adherence"": 60,
      ""reason"": ""Scaling behavior is delegated to a replaceable scalableListener with calls to scale(), getLeft(), and getTop(), allowing different scaling strategies. However, the field and setter are typed as BaseScalable instead of the ScalableListener interface, reducing substitutability and flexibility.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 65,
      ""reason"": ""The class publishes display change events via DisplayChangeEventHandler.getInstance().fireEvent(displayChangeEvent) when internal state changes are queued and processed, decoupling the notifier from observers. The subject does not manage subscribers directly but uses a centralized event handler, which is a common Observer-style event bus.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 45,
      ""adherence"": 50,
      ""reason"": ""The code acquires an OperatingSystemInterface via OperatingSystemFactory.getInstance().getOperatingSystemInstance(), suggesting factory-based creation of OS-specific implementations. Details of the factory are not present in this snippet, so the identification is based on usage and naming, with limited evidence.""
    }
  ]
}",76.903857
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gpt-5,Strategy,80,60,"Scaling behavior is delegated to a replaceable scalableListener with calls to scale(), getLeft(), and getTop(), allowing different scaling strategies. However, the field and setter are typed as BaseScalable instead of the ScalableListener interface, reducing substitutability and flexibility.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 50,
      ""reason"": ""The class exposes a single static final instance (SINGLETON) and a getInstance() accessor, indicating a Singleton. However, there is no private constructor, so external code can still instantiate the class (default public constructor), which breaks the Singleton guarantee. Eager initialization is thread-safe.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 80,
      ""adherence"": 60,
      ""reason"": ""Scaling behavior is delegated to a replaceable scalableListener with calls to scale(), getLeft(), and getTop(), allowing different scaling strategies. However, the field and setter are typed as BaseScalable instead of the ScalableListener interface, reducing substitutability and flexibility.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 65,
      ""reason"": ""The class publishes display change events via DisplayChangeEventHandler.getInstance().fireEvent(displayChangeEvent) when internal state changes are queued and processed, decoupling the notifier from observers. The subject does not manage subscribers directly but uses a centralized event handler, which is a common Observer-style event bus.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 45,
      ""adherence"": 50,
      ""reason"": ""The code acquires an OperatingSystemInterface via OperatingSystemFactory.getInstance().getOperatingSystemInstance(), suggesting factory-based creation of OS-specific implementations. Details of the factory are not present in this snippet, so the identification is based on usage and naming, with limited evidence.""
    }
  ]
}",76.903857
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gpt-5,Observer,85,65,"The class publishes display change events via DisplayChangeEventHandler.getInstance().fireEvent(displayChangeEvent) when internal state changes are queued and processed, decoupling the notifier from observers. The subject does not manage subscribers directly but uses a centralized event handler, which is a common Observer-style event bus.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 50,
      ""reason"": ""The class exposes a single static final instance (SINGLETON) and a getInstance() accessor, indicating a Singleton. However, there is no private constructor, so external code can still instantiate the class (default public constructor), which breaks the Singleton guarantee. Eager initialization is thread-safe.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 80,
      ""adherence"": 60,
      ""reason"": ""Scaling behavior is delegated to a replaceable scalableListener with calls to scale(), getLeft(), and getTop(), allowing different scaling strategies. However, the field and setter are typed as BaseScalable instead of the ScalableListener interface, reducing substitutability and flexibility.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 65,
      ""reason"": ""The class publishes display change events via DisplayChangeEventHandler.getInstance().fireEvent(displayChangeEvent) when internal state changes are queued and processed, decoupling the notifier from observers. The subject does not manage subscribers directly but uses a centralized event handler, which is a common Observer-style event bus.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 45,
      ""adherence"": 50,
      ""reason"": ""The code acquires an OperatingSystemInterface via OperatingSystemFactory.getInstance().getOperatingSystemInstance(), suggesting factory-based creation of OS-specific implementations. Details of the factory are not present in this snippet, so the identification is based on usage and naming, with limited evidence.""
    }
  ]
}",76.903857
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gpt-5,Abstract Factory,45,50,"The code acquires an OperatingSystemInterface via OperatingSystemFactory.getInstance().getOperatingSystemInstance(), suggesting factory-based creation of OS-specific implementations. Details of the factory are not present in this snippet, so the identification is based on usage and naming, with limited evidence.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 50,
      ""reason"": ""The class exposes a single static final instance (SINGLETON) and a getInstance() accessor, indicating a Singleton. However, there is no private constructor, so external code can still instantiate the class (default public constructor), which breaks the Singleton guarantee. Eager initialization is thread-safe.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 80,
      ""adherence"": 60,
      ""reason"": ""Scaling behavior is delegated to a replaceable scalableListener with calls to scale(), getLeft(), and getTop(), allowing different scaling strategies. However, the field and setter are typed as BaseScalable instead of the ScalableListener interface, reducing substitutability and flexibility.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 85,
      ""adherence"": 65,
      ""reason"": ""The class publishes display change events via DisplayChangeEventHandler.getInstance().fireEvent(displayChangeEvent) when internal state changes are queued and processed, decoupling the notifier from observers. The subject does not manage subscribers directly but uses a centralized event handler, which is a common Observer-style event bus.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 45,
      ""adherence"": 50,
      ""reason"": ""The code acquires an OperatingSystemInterface via OperatingSystemFactory.getInstance().getOperatingSystemInstance(), suggesting factory-based creation of OS-specific implementations. Details of the factory are not present in this snippet, so the identification is based on usage and naming, with limited evidence.""
    }
  ]
}",76.903857
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gemini-3.0-pro,Singleton,100,80,"The class follows the standard structure of the Singleton pattern by having a private static final instance of itself ('SINGLETON') and a public static method ('getInstance()') to access it. However, adherence is not 100% because the class does not explicitly define a private constructor; relying on the default compiler-generated constructor means the constructor is public, technically allowing other classes to instantiate it.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 80,
			""reason"": ""The class follows the standard structure of the Singleton pattern by having a private static final instance of itself ('SINGLETON') and a public static method ('getInstance()') to access it. However, adherence is not 100% because the class does not explicitly define a private constructor; relying on the default compiler-generated constructor means the constructor is public, technically allowing other classes to instantiate it.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class acts as a subject (publisher) in two ways. First, it allows a 'BaseScalable' listener to be registered via 'setScalableListener', and notifies it (calls 'scale') when state changes in 'setLastSize'. Second, it queues changes and utilizes the 'DisplayChangeEventHandler' to 'fireEvent', effectively publishing events to subscribers of the display change system.""
		}
	]
}
```",26.119374
DPD-AllBinary-Platform-DisplayInfoSingleton.java,singleton,gemini-3.0-pro,Observer,95,90,"The class acts as a subject (publisher) in two ways. First, it allows a 'BaseScalable' listener to be registered via 'setScalableListener', and notifies it (calls 'scale') when state changes in 'setLastSize'. Second, it queues changes and utilizes the 'DisplayChangeEventHandler' to 'fireEvent', effectively publishing events to subscribers of the display change system.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 80,
			""reason"": ""The class follows the standard structure of the Singleton pattern by having a private static final instance of itself ('SINGLETON') and a public static method ('getInstance()') to access it. However, adherence is not 100% because the class does not explicitly define a private constructor; relying on the default compiler-generated constructor means the constructor is public, technically allowing other classes to instantiate it.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class acts as a subject (publisher) in two ways. First, it allows a 'BaseScalable' listener to be registered via 'setScalableListener', and notifies it (calls 'scale') when state changes in 'setLastSize'. Second, it queues changes and utilizes the 'DisplayChangeEventHandler' to 'fireEvent', effectively publishing events to subscribers of the display change system.""
		}
	]
}
```",26.119374
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gpt-5,Singleton,95,92,"TestingInputSingleton has a private static final instance, a private constructor, and a public static accessor (getInstance). This is a classic eager-initialized singleton, which is thread-safe via class loading. No extra concerns like cloning/serialization are present here.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""TestingInputSingleton has a private static final instance, a private constructor, and a public static accessor (getInstance). This is a classic eager-initialized singleton, which is thread-safe via class loading. No extra concerns like cloning/serialization are present here.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""Each key is mapped to a GameInputProcessor anonymous class encapsulating an action (up/down/left/right/strafe). processInput acts as the invoker, iterating events and invoking process on the mapped command, while TestInputInterface is the receiver executing the actual behavior. Undo is not implemented (optional), and the event parameter is unused, but the core structure matches Command.""
    },
    {
      ""pattern"": ""Null Object"",
      ""confidence"": 90,
      ""adherence"": 95,
      ""reason"": ""paintable is initialized to NullPaintable.getInstance(), a do-nothing implementation of PaintableInterface. This avoids null checks and allows safe paint calls until a real TestInputInterface is provided.""
    }
  ]
}",48.938428
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gpt-5,Command,90,88,"Each key is mapped to a GameInputProcessor anonymous class encapsulating an action (up/down/left/right/strafe). processInput acts as the invoker, iterating events and invoking process on the mapped command, while TestInputInterface is the receiver executing the actual behavior. Undo is not implemented (optional), and the event parameter is unused, but the core structure matches Command.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""TestingInputSingleton has a private static final instance, a private constructor, and a public static accessor (getInstance). This is a classic eager-initialized singleton, which is thread-safe via class loading. No extra concerns like cloning/serialization are present here.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""Each key is mapped to a GameInputProcessor anonymous class encapsulating an action (up/down/left/right/strafe). processInput acts as the invoker, iterating events and invoking process on the mapped command, while TestInputInterface is the receiver executing the actual behavior. Undo is not implemented (optional), and the event parameter is unused, but the core structure matches Command.""
    },
    {
      ""pattern"": ""Null Object"",
      ""confidence"": 90,
      ""adherence"": 95,
      ""reason"": ""paintable is initialized to NullPaintable.getInstance(), a do-nothing implementation of PaintableInterface. This avoids null checks and allows safe paint calls until a real TestInputInterface is provided.""
    }
  ]
}",48.938428
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gpt-5,Null Object,90,95,"paintable is initialized to NullPaintable.getInstance(), a do-nothing implementation of PaintableInterface. This avoids null checks and allows safe paint calls until a real TestInputInterface is provided.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 92,
      ""reason"": ""TestingInputSingleton has a private static final instance, a private constructor, and a public static accessor (getInstance). This is a classic eager-initialized singleton, which is thread-safe via class loading. No extra concerns like cloning/serialization are present here.""
    },
    {
      ""pattern"": ""Command"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""Each key is mapped to a GameInputProcessor anonymous class encapsulating an action (up/down/left/right/strafe). processInput acts as the invoker, iterating events and invoking process on the mapped command, while TestInputInterface is the receiver executing the actual behavior. Undo is not implemented (optional), and the event parameter is unused, but the core structure matches Command.""
    },
    {
      ""pattern"": ""Null Object"",
      ""confidence"": 90,
      ""adherence"": 95,
      ""reason"": ""paintable is initialized to NullPaintable.getInstance(), a do-nothing implementation of PaintableInterface. This avoids null checks and allows safe paint calls until a real TestInputInterface is provided.""
    }
  ]
}",48.938428
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gemini-3.0-pro,Singleton,100,100,"The class implements the Singleton pattern using the eager initialization method. It possesses a private static final instance of itself, a private constructor to prevent external instantiation, and a public static accessor method ('getInstance') to provide global access to the instance.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements the Singleton pattern using the eager initialization method. It possesses a private static final instance of itself, a private constructor to prevent external instantiation, and a public static accessor method ('getInstance') to provide global access to the instance.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class utilizes the Command pattern to handle input. The 'GameInputProcessor' anonymous inner classes act as Concrete Commands, encapsulating specific requests (e.g., 'testInputInterface.up()'). These are stored in the 'inputProcessorArray' and executed via the 'process' method, decoupling the object that invokes the operation from the one that knows how to perform it.""
		},
		{
			""pattern"": ""Null Object"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The 'paintable' field is initialized with 'NullPaintable.getInstance()'. This allows the 'paint' method to call 'this.paintable.paint(graphics)' without explicitly checking if 'paintable' is null, adhering to the Null Object pattern to handle default behavior.""
		}
	]
}
```",23.342758
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gemini-3.0-pro,Command,95,90,"The class utilizes the Command pattern to handle input. The 'GameInputProcessor' anonymous inner classes act as Concrete Commands, encapsulating specific requests (e.g., 'testInputInterface.up()'). These are stored in the 'inputProcessorArray' and executed via the 'process' method, decoupling the object that invokes the operation from the one that knows how to perform it.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements the Singleton pattern using the eager initialization method. It possesses a private static final instance of itself, a private constructor to prevent external instantiation, and a public static accessor method ('getInstance') to provide global access to the instance.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class utilizes the Command pattern to handle input. The 'GameInputProcessor' anonymous inner classes act as Concrete Commands, encapsulating specific requests (e.g., 'testInputInterface.up()'). These are stored in the 'inputProcessorArray' and executed via the 'process' method, decoupling the object that invokes the operation from the one that knows how to perform it.""
		},
		{
			""pattern"": ""Null Object"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The 'paintable' field is initialized with 'NullPaintable.getInstance()'. This allows the 'paint' method to call 'this.paintable.paint(graphics)' without explicitly checking if 'paintable' is null, adhering to the Null Object pattern to handle default behavior.""
		}
	]
}
```",23.342758
DPD-AllBinary-Platform-TestingInputSingleton.java,singleton,gemini-3.0-pro,Null Object,90,100,"The 'paintable' field is initialized with 'NullPaintable.getInstance()'. This allows the 'paint' method to call 'this.paintable.paint(graphics)' without explicitly checking if 'paintable' is null, adhering to the Null Object pattern to handle default behavior.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements the Singleton pattern using the eager initialization method. It possesses a private static final instance of itself, a private constructor to prevent external instantiation, and a public static accessor method ('getInstance') to provide global access to the instance.""
		},
		{
			""pattern"": ""Command"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class utilizes the Command pattern to handle input. The 'GameInputProcessor' anonymous inner classes act as Concrete Commands, encapsulating specific requests (e.g., 'testInputInterface.up()'). These are stored in the 'inputProcessorArray' and executed via the 'process' method, decoupling the object that invokes the operation from the one that knows how to perform it.""
		},
		{
			""pattern"": ""Null Object"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The 'paintable' field is initialized with 'NullPaintable.getInstance()'. This allows the 'paint' method to call 'this.paintable.paint(graphics)' without explicitly checking if 'paintable' is null, adhering to the Null Object pattern to handle default behavior.""
		}
	]
}
```",23.342758
DPD-CIDE-ScreenSingleton.java,singleton,gpt-5,Singleton,99,85,"Class has a private static instance, a private constructor, and a public static getInstance() with lazy initialization, ensuring a single globally accessible instance. It holds shared state via getters/setters. However, it lacks thread-safety and protections against multiple instantiation via serialization/reflection, so adherence is not maximal.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 99,
      ""adherence"": 85,
      ""reason"": ""Class has a private static instance, a private constructor, and a public static getInstance() with lazy initialization, ensuring a single globally accessible instance. It holds shared state via getters/setters. However, it lacks thread-safety and protections against multiple instantiation via serialization/reflection, so adherence is not maximal.""
    }
  ]
}",16.278854
DPD-CIDE-ScreenSingleton.java,singleton,gemini-3.0-pro,Singleton,100,90,"The class strictly follows the structure of the Singleton pattern. It declares a private static variable 'instance' to hold the unique object, a private constructor to prevent external instantiation, and a public static method 'getInstance()' to provide a global access point. While it uses lazy initialization, it lacks thread-safety synchronization, which prevents a 100% adherence score for a production-ready environment.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 100,
		""adherence"": 90,
		""reason"": ""The class strictly follows the structure of the Singleton pattern. It declares a private static variable 'instance' to hold the unique object, a private constructor to prevent external instantiation, and a public static method 'getInstance()' to provide a global access point. While it uses lazy initialization, it lacks thread-safety synchronization, which prevents a 100% adherence score for a production-ready environment.""
	}]
}
```",14.836059
DPD-AllBinary-Platform-UploadMediaSingleton.java,singleton,gpt-5,Singleton,99,85,"Class enforces a single instance via a private static field (uploadMedia), a private constructor, and a public static synchronized getInstance() that lazily initializes and returns the instance. This matches the Singleton pattern. Minor deviations: no protection against reflection/serialization creating additional instances, and synchronized accessor may have performance overhead compared to holder/enum approaches.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 99,
      ""adherence"": 85,
      ""reason"": ""Class enforces a single instance via a private static field (uploadMedia), a private constructor, and a public static synchronized getInstance() that lazily initializes and returns the instance. This matches the Singleton pattern. Minor deviations: no protection against reflection/serialization creating additional instances, and synchronized accessor may have performance overhead compared to holder/enum approaches.""
    }
  ]
}",12.71145
DPD-AllBinary-Platform-UploadMediaSingleton.java,singleton,gemini-3.0-pro,Singleton,100,100,"The class implements the Singleton pattern by declaring a private static field 'uploadMedia' to hold the instance, a private constructor to prevent external instantiation, and a public static synchronized method 'getInstance()' which creates the instance if it does not exist (lazy initialization) and provides global access to it.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class implements the Singleton pattern by declaring a private static field 'uploadMedia' to hold the instance, a private constructor to prevent external instantiation, and a public static synchronized method 'getInstance()' which creates the instance if it does not exist (lazy initialization) and provides global access to it.""
	}]
}
```",15.154622
PMART-Xalan-SingletonIterator.java,singleton,gpt-5,Iterator,95,90,"Implements iteration behavior via next(), setStartNode(), and reset() while hiding the underlying structure behind the NodeIterator API. It iterates over a single element and then returns a sentinel (NodeIterator.END). Despite the class name, this is not the Singleton pattern but an iterator over a singleton collection.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""Implements iteration behavior via next(), setStartNode(), and reset() while hiding the underlying structure behind the NodeIterator API. It iterates over a single element and then returns a sentinel (NodeIterator.END). Despite the class name, this is not the Singleton pattern but an iterator over a singleton collection.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""The class extends NodeIteratorBase and relies on base-class hooks like resetPosition() and returnNode(). The superclass likely defines the algorithm skeleton for iteration, with this subclass supplying specific steps (e.g., next(), setStartNode()).""
    }
  ]
}",23.556881
PMART-Xalan-SingletonIterator.java,singleton,gpt-5,Template Method,65,70,"The class extends NodeIteratorBase and relies on base-class hooks like resetPosition() and returnNode(). The superclass likely defines the algorithm skeleton for iteration, with this subclass supplying specific steps (e.g., next(), setStartNode()).","{
  ""design_patterns"": [
    {
      ""pattern"": ""Iterator"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""Implements iteration behavior via next(), setStartNode(), and reset() while hiding the underlying structure behind the NodeIterator API. It iterates over a single element and then returns a sentinel (NodeIterator.END). Despite the class name, this is not the Singleton pattern but an iterator over a singleton collection.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""The class extends NodeIteratorBase and relies on base-class hooks like resetPosition() and returnNode(). The superclass likely defines the algorithm skeleton for iteration, with this subclass supplying specific steps (e.g., next(), setStartNode()).""
    }
  ]
}",23.556881
PMART-Xalan-SingletonIterator.java,singleton,gemini-3.0-pro,Iterator,100,100,"The class extends `NodeIteratorBase` and implements standard traversal methods like `next()` and `reset()`. It encapsulates the logic required to traverse a data set (in this specific case, a set containing a single node) sequentially without exposing the underlying representation. Despite the class name `SingletonIterator`, it does not implement the Singleton pattern (it has public constructors and no static instance management); rather, the name implies it is an Iterator for a 'singleton' collection (a collection of size 1).","```json
{
	""design_patterns"": [{
		""pattern"": ""Iterator"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class extends `NodeIteratorBase` and implements standard traversal methods like `next()` and `reset()`. It encapsulates the logic required to traverse a data set (in this specific case, a set containing a single node) sequentially without exposing the underlying representation. Despite the class name `SingletonIterator`, it does not implement the Singleton pattern (it has public constructors and no static instance management); rather, the name implies it is an Iterator for a 'singleton' collection (a collection of size 1).""
	}]
}
```",18.729535
PMART-PMARt-RuntimeSingleton.java,singleton,gpt-5,Facade,97,92,"RuntimeSingleton exposes a simple, unified API while delegating virtually all work to a single subsystem object (private static RuntimeInstance ri). Methods like init(), parse(...), getTemplate(...), getContent(...), property accessors, logging, and macro operations are thin pass-throughs to ri, hiding subsystem complexity from clients. Despite Javadoc mentioning Mediator, the code does not coordinate independent colleagues; it fronts a single underlying service, which fits Facade.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Facade"",
      ""confidence"": 97,
      ""adherence"": 92,
      ""reason"": ""RuntimeSingleton exposes a simple, unified API while delegating virtually all work to a single subsystem object (private static RuntimeInstance ri). Methods like init(), parse(...), getTemplate(...), getContent(...), property accessors, logging, and macro operations are thin pass-throughs to ri, hiding subsystem complexity from clients. Despite Javadoc mentioning Mediator, the code does not coordinate independent colleagues; it fronts a single underlying service, which fits Facade.""
    },
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 60,
      ""adherence"": 35,
      ""reason"": ""The class provides global access to a single, eagerly created RuntimeInstance (private static RuntimeInstance ri) used by all static methods, which is a singleton-like usage. However, RuntimeSingleton itself is not a proper Singleton (no private constructor, one instance method exists, and clients could instantiate the class). The singleton constraint is only applied to the internal RuntimeInstance within this wrapper, not enforced application-wide.""
    }
  ]
}",43.09745
PMART-PMARt-RuntimeSingleton.java,singleton,gpt-5,Singleton,60,35,"The class provides global access to a single, eagerly created RuntimeInstance (private static RuntimeInstance ri) used by all static methods, which is a singleton-like usage. However, RuntimeSingleton itself is not a proper Singleton (no private constructor, one instance method exists, and clients could instantiate the class). The singleton constraint is only applied to the internal RuntimeInstance within this wrapper, not enforced application-wide.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Facade"",
      ""confidence"": 97,
      ""adherence"": 92,
      ""reason"": ""RuntimeSingleton exposes a simple, unified API while delegating virtually all work to a single subsystem object (private static RuntimeInstance ri). Methods like init(), parse(...), getTemplate(...), getContent(...), property accessors, logging, and macro operations are thin pass-throughs to ri, hiding subsystem complexity from clients. Despite Javadoc mentioning Mediator, the code does not coordinate independent colleagues; it fronts a single underlying service, which fits Facade.""
    },
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 60,
      ""adherence"": 35,
      ""reason"": ""The class provides global access to a single, eagerly created RuntimeInstance (private static RuntimeInstance ri) used by all static methods, which is a singleton-like usage. However, RuntimeSingleton itself is not a proper Singleton (no private constructor, one instance method exists, and clients could instantiate the class). The singleton constraint is only applied to the internal RuntimeInstance within this wrapper, not enforced application-wide.""
    }
  ]
}",43.09745
PMART-PMARt-RuntimeSingleton.java,singleton,gemini-3.0-pro,Singleton,95,70,"The class is explicitly named 'RuntimeSingleton' and ensures a single global point of access to the Velocity Runtime via a private static 'ri' (RuntimeInstance) field. However, it deviates from the standard Gang of Four implementation by lacking a private constructor (allowing the instantiation of the stateless wrapper class) and exposing functionality through static methods rather than a 'getInstance()' method.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 95,
			""adherence"": 70,
			""reason"": ""The class is explicitly named 'RuntimeSingleton' and ensures a single global point of access to the Velocity Runtime via a private static 'ri' (RuntimeInstance) field. However, it deviates from the standard Gang of Four implementation by lacking a private constructor (allowing the instantiation of the stateless wrapper class) and exposing functionality through static methods rather than a 'getInstance()' method.""
		},
		{
			""pattern"": ""Facade"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The class acts as a 'single access point' (as described in the Javadoc) to the complex underlying Velocity system. It hides the initialization and coordination of subsystems like logging, resource management, and parsing behind a simplified static interface.""
		},
		{
			""pattern"": ""Delegation"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements almost all of its logic by forwarding method calls to the internal 'ri' (RuntimeInstance) object, adhering strictly to the delegation principle.""
		}
	]
}
```",61.928095
PMART-PMARt-RuntimeSingleton.java,singleton,gemini-3.0-pro,Facade,90,100,"The class acts as a 'single access point' (as described in the Javadoc) to the complex underlying Velocity system. It hides the initialization and coordination of subsystems like logging, resource management, and parsing behind a simplified static interface.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 95,
			""adherence"": 70,
			""reason"": ""The class is explicitly named 'RuntimeSingleton' and ensures a single global point of access to the Velocity Runtime via a private static 'ri' (RuntimeInstance) field. However, it deviates from the standard Gang of Four implementation by lacking a private constructor (allowing the instantiation of the stateless wrapper class) and exposing functionality through static methods rather than a 'getInstance()' method.""
		},
		{
			""pattern"": ""Facade"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The class acts as a 'single access point' (as described in the Javadoc) to the complex underlying Velocity system. It hides the initialization and coordination of subsystems like logging, resource management, and parsing behind a simplified static interface.""
		},
		{
			""pattern"": ""Delegation"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements almost all of its logic by forwarding method calls to the internal 'ri' (RuntimeInstance) object, adhering strictly to the delegation principle.""
		}
	]
}
```",61.928095
PMART-PMARt-RuntimeSingleton.java,singleton,gemini-3.0-pro,Delegation,100,100,"The class implements almost all of its logic by forwarding method calls to the internal 'ri' (RuntimeInstance) object, adhering strictly to the delegation principle.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 95,
			""adherence"": 70,
			""reason"": ""The class is explicitly named 'RuntimeSingleton' and ensures a single global point of access to the Velocity Runtime via a private static 'ri' (RuntimeInstance) field. However, it deviates from the standard Gang of Four implementation by lacking a private constructor (allowing the instantiation of the stateless wrapper class) and exposing functionality through static methods rather than a 'getInstance()' method.""
		},
		{
			""pattern"": ""Facade"",
			""confidence"": 90,
			""adherence"": 100,
			""reason"": ""The class acts as a 'single access point' (as described in the Javadoc) to the complex underlying Velocity system. It hides the initialization and coordination of subsystems like logging, resource management, and parsing behind a simplified static interface.""
		},
		{
			""pattern"": ""Delegation"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The class implements almost all of its logic by forwarding method calls to the internal 'ri' (RuntimeInstance) object, adhering strictly to the delegation principle.""
		}
	]
}
```",61.928095
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gpt-5,Proxy,95,90,"The class is an invocation handler (extends EjbObjectProxyHandler) used with dynamically generated proxies (ProxyManager.getInvocationHandler). It mediates method calls (e.g., isIdentical, remove), encapsulating access to the underlying EJB object, which is characteristic of the Proxy pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Proxy"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class is an invocation handler (extends EjbObjectProxyHandler) used with dynamically generated proxies (ProxyManager.getInvocationHandler). It mediates method calls (e.g., isIdentical, remove), encapsulating access to the underlying EJB object, which is characteristic of the Proxy pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""Different EjbObjectProxyHandler subclasses (e.g., for singleton vs. other session types) encapsulate varying behaviors for operations like getPrimaryKey, remove, and invalidateReference. The framework can select the appropriate handler at runtime, varying the algorithm without changing the proxy client.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""This subclass overrides specific hook methods (getPrimaryKey, isIdentical, invalidateReference, remove), implying the superclass defines an algorithm skeleton that calls these hooks. The subclass customizes steps while the overall invocation flow is controlled by the base class.""
    }
  ]
}",30.756891
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gpt-5,Strategy,65,60,"Different EjbObjectProxyHandler subclasses (e.g., for singleton vs. other session types) encapsulate varying behaviors for operations like getPrimaryKey, remove, and invalidateReference. The framework can select the appropriate handler at runtime, varying the algorithm without changing the proxy client.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Proxy"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class is an invocation handler (extends EjbObjectProxyHandler) used with dynamically generated proxies (ProxyManager.getInvocationHandler). It mediates method calls (e.g., isIdentical, remove), encapsulating access to the underlying EJB object, which is characteristic of the Proxy pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""Different EjbObjectProxyHandler subclasses (e.g., for singleton vs. other session types) encapsulate varying behaviors for operations like getPrimaryKey, remove, and invalidateReference. The framework can select the appropriate handler at runtime, varying the algorithm without changing the proxy client.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""This subclass overrides specific hook methods (getPrimaryKey, isIdentical, invalidateReference, remove), implying the superclass defines an algorithm skeleton that calls these hooks. The subclass customizes steps while the overall invocation flow is controlled by the base class.""
    }
  ]
}",30.756891
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gpt-5,Template Method,55,55,"This subclass overrides specific hook methods (getPrimaryKey, isIdentical, invalidateReference, remove), implying the superclass defines an algorithm skeleton that calls these hooks. The subclass customizes steps while the overall invocation flow is controlled by the base class.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Proxy"",
      ""confidence"": 95,
      ""adherence"": 90,
      ""reason"": ""The class is an invocation handler (extends EjbObjectProxyHandler) used with dynamically generated proxies (ProxyManager.getInvocationHandler). It mediates method calls (e.g., isIdentical, remove), encapsulating access to the underlying EJB object, which is characteristic of the Proxy pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""Different EjbObjectProxyHandler subclasses (e.g., for singleton vs. other session types) encapsulate varying behaviors for operations like getPrimaryKey, remove, and invalidateReference. The framework can select the appropriate handler at runtime, varying the algorithm without changing the proxy client.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""This subclass overrides specific hook methods (getPrimaryKey, isIdentical, invalidateReference, remove), implying the superclass defines an algorithm skeleton that calls these hooks. The subclass customizes steps while the overall invocation flow is controlled by the base class.""
    }
  ]
}",30.756891
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gemini-3.0-pro,Proxy,95,90,"The class extends `EjbObjectProxyHandler` and functions as an invocation handler. It intercepts method calls (e.g., `getPrimaryKey`, `isIdentical`) intended for an object to control access and modify behavior, which is the core intent of the Proxy pattern. While the actual Proxy object is likely generated dynamically, this class contains the specific proxying logic.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Proxy"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class extends `EjbObjectProxyHandler` and functions as an invocation handler. It intercepts method calls (e.g., `getPrimaryKey`, `isIdentical`) intended for an object to control access and modify behavior, which is the core intent of the Proxy pattern. While the actual Proxy object is likely generated dynamically, this class contains the specific proxying logic.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `getRegistryId` method explicitly implements this pattern. It checks if `registryId` is null; if so, it calculates and assigns the value using `createRegistryId` before returning it, ensuring the heavy lifting is done only on demand.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 85,
			""reason"": ""The class inherits from `EjbObjectProxyHandler` and overrides specific protected methods (`getPrimaryKey`, `isIdentical`, `remove`). These methods function as hooks or specific steps within a general algorithm (likely the `invoke` method) defined in the parent class, allowing the subclass to provide specific implementations for Singleton EJBs while preserving the parent's control flow.""
		}
	]
}
```",38.601408
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gemini-3.0-pro,Lazy Initialization,100,100,"The `getRegistryId` method explicitly implements this pattern. It checks if `registryId` is null; if so, it calculates and assigns the value using `createRegistryId` before returning it, ensuring the heavy lifting is done only on demand.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Proxy"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class extends `EjbObjectProxyHandler` and functions as an invocation handler. It intercepts method calls (e.g., `getPrimaryKey`, `isIdentical`) intended for an object to control access and modify behavior, which is the core intent of the Proxy pattern. While the actual Proxy object is likely generated dynamically, this class contains the specific proxying logic.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `getRegistryId` method explicitly implements this pattern. It checks if `registryId` is null; if so, it calculates and assigns the value using `createRegistryId` before returning it, ensuring the heavy lifting is done only on demand.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 85,
			""reason"": ""The class inherits from `EjbObjectProxyHandler` and overrides specific protected methods (`getPrimaryKey`, `isIdentical`, `remove`). These methods function as hooks or specific steps within a general algorithm (likely the `invoke` method) defined in the parent class, allowing the subclass to provide specific implementations for Singleton EJBs while preserving the parent's control flow.""
		}
	]
}
```",38.601408
DPD-openejb-SingletonEjbObjectHandler.java,singleton,gemini-3.0-pro,Template Method,85,85,"The class inherits from `EjbObjectProxyHandler` and overrides specific protected methods (`getPrimaryKey`, `isIdentical`, `remove`). These methods function as hooks or specific steps within a general algorithm (likely the `invoke` method) defined in the parent class, allowing the subclass to provide specific implementations for Singleton EJBs while preserving the parent's control flow.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Proxy"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class extends `EjbObjectProxyHandler` and functions as an invocation handler. It intercepts method calls (e.g., `getPrimaryKey`, `isIdentical`) intended for an object to control access and modify behavior, which is the core intent of the Proxy pattern. While the actual Proxy object is likely generated dynamically, this class contains the specific proxying logic.""
		},
		{
			""pattern"": ""Lazy Initialization"",
			""confidence"": 100,
			""adherence"": 100,
			""reason"": ""The `getRegistryId` method explicitly implements this pattern. It checks if `registryId` is null; if so, it calculates and assigns the value using `createRegistryId` before returning it, ensuring the heavy lifting is done only on demand.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 85,
			""reason"": ""The class inherits from `EjbObjectProxyHandler` and overrides specific protected methods (`getPrimaryKey`, `isIdentical`, `remove`). These methods function as hooks or specific steps within a general algorithm (likely the `invoke` method) defined in the parent class, allowing the subclass to provide specific implementations for Singleton EJBs while preserving the parent's control flow.""
		}
	]
}
```",38.601408
PMART-PMARt-ScalaSingletonTrait$.java,singleton,gpt-5,Singleton,85,55,"Exposes a single global instance via a public static final field (eager initialization), and the class is final to prevent subclassing. However, the constructor is not private, so external code could create additional instances, weakening the singleton guarantee.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 85,
      ""adherence"": 55,
      ""reason"": ""Exposes a single global instance via a public static final field (eager initialization), and the class is final to prevent subclassing. However, the constructor is not private, so external code could create additional instances, weakening the singleton guarantee.""
    }
  ]
}",15.393798
PMART-PMARt-ScalaSingletonTrait$.java,singleton,gemini-3.0-pro,Singleton,95,60,"The code demonstrates the Singleton pattern, specifically the idiom used when Scala 'object' definitions are compiled for Java interoperability (indicated by the 'MODULE$' static field). It provides a global point of access via the public static final field. However, the adherence is compromised because the class lacks an explicit private constructor. In Java, this results in a default public constructor, which allows external clients to instantiate the class multiple times, violating the strict constraint that a Singleton must ensure only one instance exists.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 95,
		""adherence"": 60,
		""reason"": ""The code demonstrates the Singleton pattern, specifically the idiom used when Scala 'object' definitions are compiled for Java interoperability (indicated by the 'MODULE$' static field). It provides a global point of access via the public static final field. However, the adherence is compromised because the class lacks an explicit private constructor. In Java, this results in a default public constructor, which allows external clients to instantiate the class multiple times, violating the strict constraint that a Singleton must ensure only one instance exists.""
	}]
}
```",17.578187
DPD-alfresco-TransactionAwareSingleton.java,singleton,gpt-5,Observer,92,90,The class registers itself as a listener to the transaction manager (AlfrescoTransactionSupport.bindListener(this)) and reacts to lifecycle callbacks (afterCommit) to promote state. This is a classic subject (transaction manager) notifying observers (listeners) arrangement.,"{""design_patterns"": [{""pattern"": ""Observer"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class registers itself as a listener to the transaction manager (AlfrescoTransactionSupport.bindListener(this)) and reacts to lifecycle callbacks (afterCommit) to promote state. This is a classic subject (transaction manager) notifying observers (listeners) arrangement.""}, {""pattern"": ""Read-Write Lock"", ""confidence"": 95, ""adherence"": 100, ""reason"": ""Concurrent access to the shared tenantSingletonValue is coordinated via ReentrantReadWriteLock, using the read lock for reads and the write lock for updates, allowing multiple concurrent readers and exclusive writers.""}, {""pattern"": ""Lazy Initialization"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Transaction-local storage and listener registration are created on first mutation within a transaction (in put): if no TransactionStorage is present, it is allocated and the listener is bound. Resources are thus initialized only when needed.""}]}",67.462602
DPD-alfresco-TransactionAwareSingleton.java,singleton,gpt-5,Read-Write Lock,95,100,"Concurrent access to the shared tenantSingletonValue is coordinated via ReentrantReadWriteLock, using the read lock for reads and the write lock for updates, allowing multiple concurrent readers and exclusive writers.","{""design_patterns"": [{""pattern"": ""Observer"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class registers itself as a listener to the transaction manager (AlfrescoTransactionSupport.bindListener(this)) and reacts to lifecycle callbacks (afterCommit) to promote state. This is a classic subject (transaction manager) notifying observers (listeners) arrangement.""}, {""pattern"": ""Read-Write Lock"", ""confidence"": 95, ""adherence"": 100, ""reason"": ""Concurrent access to the shared tenantSingletonValue is coordinated via ReentrantReadWriteLock, using the read lock for reads and the write lock for updates, allowing multiple concurrent readers and exclusive writers.""}, {""pattern"": ""Lazy Initialization"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Transaction-local storage and listener registration are created on first mutation within a transaction (in put): if no TransactionStorage is present, it is allocated and the listener is bound. Resources are thus initialized only when needed.""}]}",67.462602
DPD-alfresco-TransactionAwareSingleton.java,singleton,gpt-5,Lazy Initialization,80,85,"Transaction-local storage and listener registration are created on first mutation within a transaction (in put): if no TransactionStorage is present, it is allocated and the listener is bound. Resources are thus initialized only when needed.","{""design_patterns"": [{""pattern"": ""Observer"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class registers itself as a listener to the transaction manager (AlfrescoTransactionSupport.bindListener(this)) and reacts to lifecycle callbacks (afterCommit) to promote state. This is a classic subject (transaction manager) notifying observers (listeners) arrangement.""}, {""pattern"": ""Read-Write Lock"", ""confidence"": 95, ""adherence"": 100, ""reason"": ""Concurrent access to the shared tenantSingletonValue is coordinated via ReentrantReadWriteLock, using the read lock for reads and the write lock for updates, allowing multiple concurrent readers and exclusive writers.""}, {""pattern"": ""Lazy Initialization"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Transaction-local storage and listener registration are created on first mutation within a transaction (in put): if no TransactionStorage is present, it is allocated and the listener is bound. Resources are thus initialized only when needed.""}]}",67.462602
DPD-alfresco-TransactionAwareSingleton.java,singleton,gemini-3.0-pro,Observer,98,100,"The class implements the Observer pattern (also known as Publisher-Subscriber). It acts as a subscriber by extending 'TransactionListenerAdapter' and explicitly registering itself to the 'AlfrescoTransactionSupport' (the publisher) using 'bindListener(this)'. The 'afterCommit' method serves as the update mechanism, which is invoked when the transaction completes.","```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 98,
			""adherence"": 100,
			""reason"": ""The class implements the Observer pattern (also known as Publisher-Subscriber). It acts as a subscriber by extending 'TransactionListenerAdapter' and explicitly registering itself to the 'AlfrescoTransactionSupport' (the publisher) using 'bindListener(this)'. The 'afterCommit' method serves as the update mechanism, which is invoked when the transaction completes.""
		},
		{
			""pattern"": ""Proxy"",
			""confidence"": 85,
			""adherence"": 80,
			""reason"": ""The class functions as a Proxy (specifically a Smart Reference) for the underlying generic object 'T'. The 'get()' and 'put()' methods intercept access to the data to inject additional logic: they check for active transactions via 'AlfrescoTransactionSupport' and manage concurrency using 'ReentrantReadWriteLock' before accessing or modifying the actual stored value.""
		}
	]
}
```",38.82393
DPD-alfresco-TransactionAwareSingleton.java,singleton,gemini-3.0-pro,Proxy,85,80,The class functions as a Proxy (specifically a Smart Reference) for the underlying generic object 'T'. The 'get()' and 'put()' methods intercept access to the data to inject additional logic: they check for active transactions via 'AlfrescoTransactionSupport' and manage concurrency using 'ReentrantReadWriteLock' before accessing or modifying the actual stored value.,"```json
{
	""design_patterns"": [{
			""pattern"": ""Observer"",
			""confidence"": 98,
			""adherence"": 100,
			""reason"": ""The class implements the Observer pattern (also known as Publisher-Subscriber). It acts as a subscriber by extending 'TransactionListenerAdapter' and explicitly registering itself to the 'AlfrescoTransactionSupport' (the publisher) using 'bindListener(this)'. The 'afterCommit' method serves as the update mechanism, which is invoked when the transaction completes.""
		},
		{
			""pattern"": ""Proxy"",
			""confidence"": 85,
			""adherence"": 80,
			""reason"": ""The class functions as a Proxy (specifically a Smart Reference) for the underlying generic object 'T'. The 'get()' and 'put()' methods intercept access to the data to inject additional logic: they check for active transactions via 'AlfrescoTransactionSupport' and manage concurrency using 'ReentrantReadWriteLock' before accessing or modifying the actual stored value.""
		}
	]
}
```",38.82393
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gpt-5,Template Method,85,88,The class extends a framework base (CrUML) and overrides predicate2 to provide the specific check while the evaluation flow (when/how a critic runs) is defined in the superclass. This is a classic hook method overridden within a fixed algorithm.,"{
  ""design_patterns"": [
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""The class extends a framework base (CrUML) and overrides predicate2 to provide the specific check while the evaluation flow (when/how a critic runs) is defined in the superclass. This is a classic hook method overridden within a fixed algorithm.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each Critic encapsulates a distinct validation algorithm (here, the singleton static attribute check) that the framework can select and apply interchangeably. The predicate2 contract serves as the strategy interface for different Critic implementations.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The critic registers interest in model changes via addTrigger(\""stereotype\"", \""structuralFeature\"", \""associationEnd\""). This indicates a publish/subscribe mechanism where changes notify interested critics, consistent with the observer pattern.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""Interactions with the UML model are funneled through Model.getFacade(), which exposes simple, coarse-grained methods (isAClass, isSingleton, getAttributes, isClassifierScope, getType), hiding the underlying model complexity. This is a textbook facade usage.""
    }
  ]
}",45.339409
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gpt-5,Strategy,70,65,"Each Critic encapsulates a distinct validation algorithm (here, the singleton static attribute check) that the framework can select and apply interchangeably. The predicate2 contract serves as the strategy interface for different Critic implementations.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""The class extends a framework base (CrUML) and overrides predicate2 to provide the specific check while the evaluation flow (when/how a critic runs) is defined in the superclass. This is a classic hook method overridden within a fixed algorithm.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each Critic encapsulates a distinct validation algorithm (here, the singleton static attribute check) that the framework can select and apply interchangeably. The predicate2 contract serves as the strategy interface for different Critic implementations.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The critic registers interest in model changes via addTrigger(\""stereotype\"", \""structuralFeature\"", \""associationEnd\""). This indicates a publish/subscribe mechanism where changes notify interested critics, consistent with the observer pattern.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""Interactions with the UML model are funneled through Model.getFacade(), which exposes simple, coarse-grained methods (isAClass, isSingleton, getAttributes, isClassifierScope, getType), hiding the underlying model complexity. This is a textbook facade usage.""
    }
  ]
}",45.339409
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gpt-5,Observer,65,60,"The critic registers interest in model changes via addTrigger(""stereotype"", ""structuralFeature"", ""associationEnd""). This indicates a publish/subscribe mechanism where changes notify interested critics, consistent with the observer pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""The class extends a framework base (CrUML) and overrides predicate2 to provide the specific check while the evaluation flow (when/how a critic runs) is defined in the superclass. This is a classic hook method overridden within a fixed algorithm.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each Critic encapsulates a distinct validation algorithm (here, the singleton static attribute check) that the framework can select and apply interchangeably. The predicate2 contract serves as the strategy interface for different Critic implementations.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The critic registers interest in model changes via addTrigger(\""stereotype\"", \""structuralFeature\"", \""associationEnd\""). This indicates a publish/subscribe mechanism where changes notify interested critics, consistent with the observer pattern.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""Interactions with the UML model are funneled through Model.getFacade(), which exposes simple, coarse-grained methods (isAClass, isSingleton, getAttributes, isClassifierScope, getType), hiding the underlying model complexity. This is a textbook facade usage.""
    }
  ]
}",45.339409
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gpt-5,Facade,90,90,"Interactions with the UML model are funneled through Model.getFacade(), which exposes simple, coarse-grained methods (isAClass, isSingleton, getAttributes, isClassifierScope, getType), hiding the underlying model complexity. This is a textbook facade usage.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""The class extends a framework base (CrUML) and overrides predicate2 to provide the specific check while the evaluation flow (when/how a critic runs) is defined in the superclass. This is a classic hook method overridden within a fixed algorithm.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""Each Critic encapsulates a distinct validation algorithm (here, the singleton static attribute check) that the framework can select and apply interchangeably. The predicate2 contract serves as the strategy interface for different Critic implementations.""
    },
    {
      ""pattern"": ""Observer"",
      ""confidence"": 65,
      ""adherence"": 60,
      ""reason"": ""The critic registers interest in model changes via addTrigger(\""stereotype\"", \""structuralFeature\"", \""associationEnd\""). This indicates a publish/subscribe mechanism where changes notify interested critics, consistent with the observer pattern.""
    },
    {
      ""pattern"": ""Facade"",
      ""confidence"": 90,
      ""adherence"": 90,
      ""reason"": ""Interactions with the UML model are funneled through Model.getFacade(), which exposes simple, coarse-grained methods (isAClass, isSingleton, getAttributes, isClassifierScope, getType), hiding the underlying model complexity. This is a textbook facade usage.""
    }
  ]
}",45.339409
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gemini-3.0-pro,Strategy,95,100,"The class extends `CrUML` and acts as a concrete implementation of a validation rule (Critic). It encapsulates a specific algorithm in the `predicate2` method to check for missing static attributes. This structure allows the application to define a family of interchangeable algorithms (critics) that can be applied to the model, matching the Strategy pattern definition.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Strategy"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class extends `CrUML` and acts as a concrete implementation of a validation rule (Critic). It encapsulates a specific algorithm in the `predicate2` method to check for missing static attributes. This structure allows the application to define a family of interchangeable algorithms (critics) that can be applied to the model, matching the Strategy pattern definition.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 90,
			""adherence"": 75,
			""reason"": ""The constructor calls `addTrigger` multiple times (e.g., `addTrigger(\""stereotype\"")`), which indicates that this object subscribes to specific events or changes in the model. This is a Publisher-Subscriber mechanism where the Critic (Observer) registers itself to be notified of changes to specific model elements.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 80,
			""reason"": ""The class overrides `predicate2`, which functions as a hook method or primitive operation. This implies that the superclass (`CrUML`) implements a Template Method (likely the main critique workflow) that calls `predicate2` to execute the specific logic defined in this subclass.""
		}
	]
}
```",75.806084
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gemini-3.0-pro,Observer,90,75,"The constructor calls `addTrigger` multiple times (e.g., `addTrigger(""stereotype"")`), which indicates that this object subscribes to specific events or changes in the model. This is a Publisher-Subscriber mechanism where the Critic (Observer) registers itself to be notified of changes to specific model elements.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Strategy"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class extends `CrUML` and acts as a concrete implementation of a validation rule (Critic). It encapsulates a specific algorithm in the `predicate2` method to check for missing static attributes. This structure allows the application to define a family of interchangeable algorithms (critics) that can be applied to the model, matching the Strategy pattern definition.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 90,
			""adherence"": 75,
			""reason"": ""The constructor calls `addTrigger` multiple times (e.g., `addTrigger(\""stereotype\"")`), which indicates that this object subscribes to specific events or changes in the model. This is a Publisher-Subscriber mechanism where the Critic (Observer) registers itself to be notified of changes to specific model elements.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 80,
			""reason"": ""The class overrides `predicate2`, which functions as a hook method or primitive operation. This implies that the superclass (`CrUML`) implements a Template Method (likely the main critique workflow) that calls `predicate2` to execute the specific logic defined in this subclass.""
		}
	]
}
```",75.806084
PMART-ArgoUML-CrSingletonViolatedMissingStaticAttr.java,singleton,gemini-3.0-pro,Template Method,85,80,"The class overrides `predicate2`, which functions as a hook method or primitive operation. This implies that the superclass (`CrUML`) implements a Template Method (likely the main critique workflow) that calls `predicate2` to execute the specific logic defined in this subclass.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Strategy"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class extends `CrUML` and acts as a concrete implementation of a validation rule (Critic). It encapsulates a specific algorithm in the `predicate2` method to check for missing static attributes. This structure allows the application to define a family of interchangeable algorithms (critics) that can be applied to the model, matching the Strategy pattern definition.""
		},
		{
			""pattern"": ""Observer"",
			""confidence"": 90,
			""adherence"": 75,
			""reason"": ""The constructor calls `addTrigger` multiple times (e.g., `addTrigger(\""stereotype\"")`), which indicates that this object subscribes to specific events or changes in the model. This is a Publisher-Subscriber mechanism where the Critic (Observer) registers itself to be notified of changes to specific model elements.""
		},
		{
			""pattern"": ""Template Method"",
			""confidence"": 85,
			""adherence"": 80,
			""reason"": ""The class overrides `predicate2`, which functions as a hook method or primitive operation. This implies that the superclass (`CrUML`) implements a Template Method (likely the main critique workflow) that calls `predicate2` to execute the specific logic defined in this subclass.""
		}
	]
}
```",75.806084
DPD-AllBinary-Platform-ConstrainedMotionRectanglesResultsCacheSingleton.java,singleton,gpt-5,Singleton,95,88,"The class enforces a single, globally accessible instance of a CacheInterface via a private static field initialized in a static block, a private constructor to prevent instantiation, and a public static getInstance() accessor. Java static initialization ensures thread safety. While the singleton instance is of CacheInterface (not this class), the class acts as a singleton provider. Minor deviation: if the static block throws, getInstance() may return null, slightly weakening robustness.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 88,
      ""reason"": ""The class enforces a single, globally accessible instance of a CacheInterface via a private static field initialized in a static block, a private constructor to prevent instantiation, and a public static getInstance() accessor. Java static initialization ensures thread safety. While the singleton instance is of CacheInterface (not this class), the class acts as a singleton provider. Minor deviation: if the static block throws, getInstance() may return null, slightly weakening robustness.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 65,
      ""reason"": ""Object creation is delegated to CacheInterfaceFactory.getInstance(...) using parameters from CacheTypeFactory and CachePolicyFactory. This decouples the client from concrete cache implementations and selection logic, consistent with factory usage. However, this class only uses the factories; it does not implement the factory pattern itself, and without the factory implementations present, the exact variant (simple factory vs. factory method/abstract factory) cannot be confirmed.""
    }
  ]
}",55.877681
DPD-AllBinary-Platform-ConstrainedMotionRectanglesResultsCacheSingleton.java,singleton,gpt-5,Factory Method,60,65,"Object creation is delegated to CacheInterfaceFactory.getInstance(...) using parameters from CacheTypeFactory and CachePolicyFactory. This decouples the client from concrete cache implementations and selection logic, consistent with factory usage. However, this class only uses the factories; it does not implement the factory pattern itself, and without the factory implementations present, the exact variant (simple factory vs. factory method/abstract factory) cannot be confirmed.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 88,
      ""reason"": ""The class enforces a single, globally accessible instance of a CacheInterface via a private static field initialized in a static block, a private constructor to prevent instantiation, and a public static getInstance() accessor. Java static initialization ensures thread safety. While the singleton instance is of CacheInterface (not this class), the class acts as a singleton provider. Minor deviation: if the static block throws, getInstance() may return null, slightly weakening robustness.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 60,
      ""adherence"": 65,
      ""reason"": ""Object creation is delegated to CacheInterfaceFactory.getInstance(...) using parameters from CacheTypeFactory and CachePolicyFactory. This decouples the client from concrete cache implementations and selection logic, consistent with factory usage. However, this class only uses the factories; it does not implement the factory pattern itself, and without the factory implementations present, the exact variant (simple factory vs. factory method/abstract factory) cannot be confirmed.""
    }
  ]
}",55.877681
DPD-AllBinary-Platform-ConstrainedMotionRectanglesResultsCacheSingleton.java,singleton,gemini-3.0-pro,Singleton,100,90,"The class explicitly implements the Singleton pattern mechanics: it has a private constructor to prevent external instantiation, a private static field (`cacheInterface`) to hold the single instance, and a public static accessor method (`getInstance()`) to provide global access to that instance. While the return type is an interface (`CacheInterface`) rather than the class type itself, the structural enforcement of a single shared resource is identical to the pattern definition.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 100,
		""adherence"": 90,
		""reason"": ""The class explicitly implements the Singleton pattern mechanics: it has a private constructor to prevent external instantiation, a private static field (`cacheInterface`) to hold the single instance, and a public static accessor method (`getInstance()`) to provide global access to that instance. While the return type is an interface (`CacheInterface`) rather than the class type itself, the structural enforcement of a single shared resource is identical to the pattern definition.""
	}]
}
```",17.205782
DPD-AllBinary-Platform-PrimitiveLongSingleton.java,singleton,gpt-5,Singleton,92,30,"Class holds a private static final instance and exposes a public static getInstance(), indicating Singleton intent. However, there is no private constructor (default constructor is public), allowing external instantiation and breaking uniqueness. The class is not final, enabling subclassing to create more instances, and no safeguards against cloning/serialization. Eager static initialization is thread-safe, but core enforcement is missing.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 92,
      ""adherence"": 30,
      ""reason"": ""Class holds a private static final instance and exposes a public static getInstance(), indicating Singleton intent. However, there is no private constructor (default constructor is public), allowing external instantiation and breaking uniqueness. The class is not final, enabling subclassing to create more instances, and no safeguards against cloning/serialization. Eager static initialization is thread-safe, but core enforcement is missing.""
    }
  ]
}",22.015551
DPD-AllBinary-Platform-PrimitiveLongSingleton.java,singleton,gemini-3.0-pro,Singleton,98,50,"The code exhibits the intent and partial structure of the Singleton pattern (specifically Eager Initialization) by including a 'private static final' instance and a 'public static' accessor method (getInstance). However, the pattern adherence is significantly compromised because the class fails to define a private constructor. Since no constructor is defined, Java provides a default public constructor, which allows external classes to instantiate new objects using 'new PrimitiveLongSingleton()', thereby violating the core restriction of the pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 98,
		""adherence"": 50,
		""reason"": ""The code exhibits the intent and partial structure of the Singleton pattern (specifically Eager Initialization) by including a 'private static final' instance and a 'public static' accessor method (getInstance). However, the pattern adherence is significantly compromised because the class fails to define a private constructor. Since no constructor is defined, Java provides a default public constructor, which allows external classes to instantiate new objects using 'new PrimitiveLongSingleton()', thereby violating the core restriction of the pattern.""
	}]
}
```",19.035432
DPD-AllBinary-Platform-GameConfigurationPersistanceSingleton.java,singleton,gpt-5,Singleton,98,85,"Implements a classic eager-initialized singleton: a private static instance (GAME_PERSISTANCE) is created at class load time, a public static getInstance() returns it, and the constructor is private to prevent external instantiation. This ensures a single global instance and is thread-safe due to class initialization semantics. Minor deviations: the instance field is not final, the class is not final, and there are no protections against reflection/serialization/cloning creating additional instances.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 98,
      ""adherence"": 85,
      ""reason"": ""Implements a classic eager-initialized singleton: a private static instance (GAME_PERSISTANCE) is created at class load time, a public static getInstance() returns it, and the constructor is private to prevent external instantiation. This ensures a single global instance and is thread-safe due to class initialization semantics. Minor deviations: the instance field is not final, the class is not final, and there are no protections against reflection/serialization/cloning creating additional instances.""
    }
  ]
}",18.693831
DPD-AllBinary-Platform-GameConfigurationPersistanceSingleton.java,singleton,gemini-3.0-pro,Singleton,100,100,"The class implements the Singleton pattern using the Eager Initialization approach. It contains a private static instance of itself, a private constructor to prevent external instantiation, and a public static method ('getInstance') to provide a global access point to that specific instance.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class implements the Singleton pattern using the Eager Initialization approach. It contains a private static instance of itself, a private constructor to prevent external instantiation, and a public static method ('getInstance') to provide a global access point to that specific instance.""
	}]
}
```",17.050363
PMART-PMARt-UseSingletonRule.java,singleton,gpt-5,Visitor,98,95,"The class implements multiple visit(...) methods for different AST node types and uses cu.childrenAccept(this, data) to traverse. This double-dispatch mechanism, where nodes accept a visitor and call back the appropriate visit method, is the hallmark of the Visitor pattern. Despite the class name, it does not implement a Singleton.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Visitor"",
      ""confidence"": 98,
      ""adherence"": 95,
      ""reason"": ""The class implements multiple visit(...) methods for different AST node types and uses cu.childrenAccept(this, data) to traverse. This double-dispatch mechanism, where nodes accept a visitor and call back the appropriate visit method, is the hallmark of the Visitor pattern. Despite the class name, it does not implement a Singleton.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 62,
      ""adherence"": 70,
      ""reason"": ""UseSingletonRule extends AbstractRule to encapsulate a specific analysis algorithm (a rule) that can be applied to an AST. Different rule implementations are interchangeable without modifying the rule engine, which aligns with the Strategy pattern.""
    },
    {
      ""pattern"": ""Composite"",
      ""confidence"": 50,
      ""adherence"": 60,
      ""reason"": ""The AST appears to be a tree of nodes navigated uniformly via childrenAccept, implying a whole-part hierarchy typical of Composite. While the composite structure itself is not shown, its use is suggested by the traversal API.""
    }
  ]
}",48.02517
PMART-PMARt-UseSingletonRule.java,singleton,gpt-5,Strategy,62,70,"UseSingletonRule extends AbstractRule to encapsulate a specific analysis algorithm (a rule) that can be applied to an AST. Different rule implementations are interchangeable without modifying the rule engine, which aligns with the Strategy pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Visitor"",
      ""confidence"": 98,
      ""adherence"": 95,
      ""reason"": ""The class implements multiple visit(...) methods for different AST node types and uses cu.childrenAccept(this, data) to traverse. This double-dispatch mechanism, where nodes accept a visitor and call back the appropriate visit method, is the hallmark of the Visitor pattern. Despite the class name, it does not implement a Singleton.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 62,
      ""adherence"": 70,
      ""reason"": ""UseSingletonRule extends AbstractRule to encapsulate a specific analysis algorithm (a rule) that can be applied to an AST. Different rule implementations are interchangeable without modifying the rule engine, which aligns with the Strategy pattern.""
    },
    {
      ""pattern"": ""Composite"",
      ""confidence"": 50,
      ""adherence"": 60,
      ""reason"": ""The AST appears to be a tree of nodes navigated uniformly via childrenAccept, implying a whole-part hierarchy typical of Composite. While the composite structure itself is not shown, its use is suggested by the traversal API.""
    }
  ]
}",48.02517
PMART-PMARt-UseSingletonRule.java,singleton,gpt-5,Composite,50,60,"The AST appears to be a tree of nodes navigated uniformly via childrenAccept, implying a whole-part hierarchy typical of Composite. While the composite structure itself is not shown, its use is suggested by the traversal API.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Visitor"",
      ""confidence"": 98,
      ""adherence"": 95,
      ""reason"": ""The class implements multiple visit(...) methods for different AST node types and uses cu.childrenAccept(this, data) to traverse. This double-dispatch mechanism, where nodes accept a visitor and call back the appropriate visit method, is the hallmark of the Visitor pattern. Despite the class name, it does not implement a Singleton.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 62,
      ""adherence"": 70,
      ""reason"": ""UseSingletonRule extends AbstractRule to encapsulate a specific analysis algorithm (a rule) that can be applied to an AST. Different rule implementations are interchangeable without modifying the rule engine, which aligns with the Strategy pattern.""
    },
    {
      ""pattern"": ""Composite"",
      ""confidence"": 50,
      ""adherence"": 60,
      ""reason"": ""The AST appears to be a tree of nodes navigated uniformly via childrenAccept, implying a whole-part hierarchy typical of Composite. While the composite structure itself is not shown, its use is suggested by the traversal API.""
    }
  ]
}",48.02517
PMART-PMARt-UseSingletonRule.java,singleton,gemini-3.0-pro,Visitor,100,100,"The class functions as a Concrete Visitor. It implements multiple 'visit' methods for specific types of objects (ASTCompilationUnit, ASTFieldDeclaration, ASTConstructorDeclaration, etc.) and utilizes the 'childrenAccept(this, data)' method to traverse the structure. This is the standard Double Dispatch mechanism used in the Visitor pattern to separate the algorithm (the rule logic) from the object structure (the Abstract Syntax Tree).","```json
{
	""design_patterns"": [{
		""pattern"": ""Visitor"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class functions as a Concrete Visitor. It implements multiple 'visit' methods for specific types of objects (ASTCompilationUnit, ASTFieldDeclaration, ASTConstructorDeclaration, etc.) and utilizes the 'childrenAccept(this, data)' method to traverse the structure. This is the standard Double Dispatch mechanism used in the Visitor pattern to separate the algorithm (the rule logic) from the object structure (the Abstract Syntax Tree).""
	}]
}
```",17.154727
PMART-PMARt-VelocimacroFactory.java,factory,gpt-5,Facade,85,88,"VelocimacroFactory centralizes and simplifies access to the macro subsystem. It coordinates initialization (initVelocimacro), configuration/permissions (blather, templateLocal, addNewAllowed, replaceAllowed), and delegates core operations to subsystems (VelocimacroManager and Runtime). Clients can add, query, retrieve, and dump macros without interacting directly with the underlying manager or runtime configuration details.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Facade"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""VelocimacroFactory centralizes and simplifies access to the macro subsystem. It coordinates initialization (initVelocimacro), configuration/permissions (blather, templateLocal, addNewAllowed, replaceAllowed), and delegates core operations to subsystems (VelocimacroManager and Runtime). Clients can add, query, retrieve, and dump macros without interacting directly with the underlying manager or runtime configuration details.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The method getVelocimacro(vmName, sourceTemplate) acts as a factory-like accessor that returns a Directive representing a macro by name (or null if absent), encapsulating the retrieval/creation decision. However, it does not use subclass overriding and delegates actual creation/storage to VelocimacroManager, making it closer to a simple factory facade than the canonical GoF Factory Method.""
    }
  ]
}",45.385298
PMART-PMARt-VelocimacroFactory.java,factory,gpt-5,Factory Method,55,45,"The method getVelocimacro(vmName, sourceTemplate) acts as a factory-like accessor that returns a Directive representing a macro by name (or null if absent), encapsulating the retrieval/creation decision. However, it does not use subclass overriding and delegates actual creation/storage to VelocimacroManager, making it closer to a simple factory facade than the canonical GoF Factory Method.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Facade"",
      ""confidence"": 85,
      ""adherence"": 88,
      ""reason"": ""VelocimacroFactory centralizes and simplifies access to the macro subsystem. It coordinates initialization (initVelocimacro), configuration/permissions (blather, templateLocal, addNewAllowed, replaceAllowed), and delegates core operations to subsystems (VelocimacroManager and Runtime). Clients can add, query, retrieve, and dump macros without interacting directly with the underlying manager or runtime configuration details.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 55,
      ""adherence"": 45,
      ""reason"": ""The method getVelocimacro(vmName, sourceTemplate) acts as a factory-like accessor that returns a Directive representing a macro by name (or null if absent), encapsulating the retrieval/creation decision. However, it does not use subclass overriding and delegates actual creation/storage to VelocimacroManager, making it closer to a simple factory facade than the canonical GoF Factory Method.""
    }
  ]
}",45.385298
PMART-PMARt-VelocimacroFactory.java,factory,gemini-3.0-pro,Facade,92,85,"Although the class is named 'VelocimacroFactory', it functions primarily as a Facade for the macro subsystem. It encapsulates the `VelocimacroManager` instance and provides a simplified, unified interface for the rest of the application to interact with macros. It handles complex initialization (loading libraries via `Runtime`), manages configuration state (permissions like `replaceAllowed`, `addNewAllowed`), and centralizes logging (`blather` logic), thereby shielding clients from the underlying complexity of macro management and storage.","```json
{
	""design_patterns"": [{
		""pattern"": ""Facade"",
		""confidence"": 92,
		""adherence"": 85,
		""reason"": ""Although the class is named 'VelocimacroFactory', it functions primarily as a Facade for the macro subsystem. It encapsulates the `VelocimacroManager` instance and provides a simplified, unified interface for the rest of the application to interact with macros. It handles complex initialization (loading libraries via `Runtime`), manages configuration state (permissions like `replaceAllowed`, `addNewAllowed`), and centralizes logging (`blather` logic), thereby shielding clients from the underlying complexity of macro management and storage.""
	}, {
		""pattern"": ""Monitor Object"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The class explicitly enforces thread safety by synchronizing access to its internal state and the underlying `vmManager`. All critical methods (`initVelocimacro`, `addVelocimacro`, `isVelocimacro`, `getVelocimacro`) use `synchronized(this)` blocks to ensure mutual exclusion, adhering strictly to the Monitor Object concurrency pattern.""
	}]
}
```",79.33758
PMART-PMARt-VelocimacroFactory.java,factory,gemini-3.0-pro,Monitor Object,95,100,"The class explicitly enforces thread safety by synchronizing access to its internal state and the underlying `vmManager`. All critical methods (`initVelocimacro`, `addVelocimacro`, `isVelocimacro`, `getVelocimacro`) use `synchronized(this)` blocks to ensure mutual exclusion, adhering strictly to the Monitor Object concurrency pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Facade"",
		""confidence"": 92,
		""adherence"": 85,
		""reason"": ""Although the class is named 'VelocimacroFactory', it functions primarily as a Facade for the macro subsystem. It encapsulates the `VelocimacroManager` instance and provides a simplified, unified interface for the rest of the application to interact with macros. It handles complex initialization (loading libraries via `Runtime`), manages configuration state (permissions like `replaceAllowed`, `addNewAllowed`), and centralizes logging (`blather` logic), thereby shielding clients from the underlying complexity of macro management and storage.""
	}, {
		""pattern"": ""Monitor Object"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The class explicitly enforces thread safety by synchronizing access to its internal state and the underlying `vmManager`. All critical methods (`initVelocimacro`, `addVelocimacro`, `isVelocimacro`, `getVelocimacro`) use `synchronized(this)` blocks to ensure mutual exclusion, adhering strictly to the Monitor Object concurrency pattern.""
	}]
}
```",79.33758
DPD-AllBinary-Platform-InputAutomationModuleConfigurationsSingletonFactory.java,factory,gpt-5,Singleton,90,70,"A single instance is created eagerly in a static field and exposed via a static getInstance(); the constructor is private to prevent instantiation of the provider class. This matches a thread-safe eager Singleton provider. Adherence is reduced because the singleton instance is of a different class (InputAutomationModuleConfigurations), so that class itself does not enforce single instantiation and could be instantiated elsewhere.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 90,
      ""adherence"": 70,
      ""reason"": ""A single instance is created eagerly in a static field and exposed via a static getInstance(); the constructor is private to prevent instantiation of the provider class. This matches a thread-safe eager Singleton provider. Adherence is reduced because the singleton instance is of a different class (InputAutomationModuleConfigurations), so that class itself does not enforce single instantiation and could be instantiated elsewhere.""
    }
  ]
}",50.53129
DPD-AllBinary-Platform-InputAutomationModuleConfigurationsSingletonFactory.java,factory,gemini-3.0-pro,Singleton,100,95,"The class implements the Singleton pattern using the Eager Initialization strategy. It defines a private constructor to prevent direct instantiation and maintains a private static instance of the `InputAutomationModuleConfigurations` object, which is initialized when the class is loaded. The public static `getInstance()` method provides a global point of access to this specific instance.","```json
{
	""design_patterns"": [{
		""pattern"": ""Singleton"",
		""confidence"": 100,
		""adherence"": 95,
		""reason"": ""The class implements the Singleton pattern using the Eager Initialization strategy. It defines a private constructor to prevent direct instantiation and maintains a private static instance of the `InputAutomationModuleConfigurations` object, which is initialized when the class is loaded. The public static `getInstance()` method provides a global point of access to this specific instance.""
	}]
}
```",33.380747
PMART-Azureus-PluginConfigUIFactoryImpl.java,factory,gpt-5,Abstract Factory,93,92,"PluginConfigUIFactory is an abstract factory defining multiple creation methods for a family of related UI config products (Parameter, EnablerParameter). PluginConfigUIFactoryImpl is the concrete factory that instantiates concrete product implementations (e.g., IntParameterImpl, StringParameterImpl, FileParameter) while hiding their classes from clients. The factory maintains shared context (PluginConfig and pluginKey) applied consistently to all created products, which is characteristic of an abstract factory producing a coherent family.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 93,
      ""adherence"": 92,
      ""reason"": ""PluginConfigUIFactory is an abstract factory defining multiple creation methods for a family of related UI config products (Parameter, EnablerParameter). PluginConfigUIFactoryImpl is the concrete factory that instantiates concrete product implementations (e.g., IntParameterImpl, StringParameterImpl, FileParameter) while hiding their classes from clients. The factory maintains shared context (PluginConfig and pluginKey) applied consistently to all created products, which is characteristic of an abstract factory producing a coherent family.""
    }
  ]
}",24.26533
PMART-Azureus-PluginConfigUIFactoryImpl.java,factory,gemini-3.0-pro,Abstract Factory,100,100,"The class implements an interface (`PluginConfigUIFactory`) that serves as an Abstract Factory, defining methods to create a family of related objects (abstract products like `Parameter` and `EnablerParameter`). The class (`PluginConfigUIFactoryImpl`) acts as the Concrete Factory, encapsulating the instantiation logic for specific concrete products (e.g., `IntParameterImpl`, `BooleanParameterImpl`, `FileParameter`) while returning them via their abstract interfaces. This decouples the client code from the specific implementation classes of the parameters.","```json
{
	""design_patterns"": [{
		""pattern"": ""Abstract Factory"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class implements an interface (`PluginConfigUIFactory`) that serves as an Abstract Factory, defining methods to create a family of related objects (abstract products like `Parameter` and `EnablerParameter`). The class (`PluginConfigUIFactoryImpl`) acts as the Concrete Factory, encapsulating the instantiation logic for specific concrete products (e.g., `IntParameterImpl`, `BooleanParameterImpl`, `FileParameter`) while returning them via their abstract interfaces. This decouples the client code from the specific implementation classes of the parameters.""
	}]
}
```",20.071293
PMART-Azureus-PEPeerTransportFactory.java,factory,gpt-5,Strategy,90,85,"Handlers implementing a common interface (PEPeerTransportExtensionHandler) are registered in a map keyed by protocol_name. createExtendedTransports looks up the appropriate handler at runtime and delegates to handler.handleExtension(manager, details). This cleanly swaps the algorithm/behavior per protocol without changing the factory. Minor gaps: no explicit unregister/default handler, and reliance on a static registry.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 90,
      ""adherence"": 85,
      ""reason"": ""Handlers implementing a common interface (PEPeerTransportExtensionHandler) are registered in a map keyed by protocol_name. createExtendedTransports looks up the appropriate handler at runtime and delegates to handler.handleExtension(manager, details). This cleanly swaps the algorithm/behavior per protocol without changing the factory. Minor gaps: no explicit unregister/default handler, and reliance on a static registry.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 75,
      ""adherence"": 60,
      ""reason"": ""Static factory methods (createTransport, createServer) return interface types (PEPeerTransport, PEPeerServer) while hiding concrete implementations (PEPeerTransportImpl, PESharedPortServerImpl). There is evidence of potential variant selection (commented configuration branch in createServer). However, this is a simple static factory utility without polymorphic creator subclasses, so it deviates from the classic GoF structure.""
    }
  ]
}",30.824677
PMART-Azureus-PEPeerTransportFactory.java,factory,gpt-5,Factory Method,75,60,"Static factory methods (createTransport, createServer) return interface types (PEPeerTransport, PEPeerServer) while hiding concrete implementations (PEPeerTransportImpl, PESharedPortServerImpl). There is evidence of potential variant selection (commented configuration branch in createServer). However, this is a simple static factory utility without polymorphic creator subclasses, so it deviates from the classic GoF structure.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 90,
      ""adherence"": 85,
      ""reason"": ""Handlers implementing a common interface (PEPeerTransportExtensionHandler) are registered in a map keyed by protocol_name. createExtendedTransports looks up the appropriate handler at runtime and delegates to handler.handleExtension(manager, details). This cleanly swaps the algorithm/behavior per protocol without changing the factory. Minor gaps: no explicit unregister/default handler, and reliance on a static registry.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 75,
      ""adherence"": 60,
      ""reason"": ""Static factory methods (createTransport, createServer) return interface types (PEPeerTransport, PEPeerServer) while hiding concrete implementations (PEPeerTransportImpl, PESharedPortServerImpl). There is evidence of potential variant selection (commented configuration branch in createServer). However, this is a simple static factory utility without polymorphic creator subclasses, so it deviates from the classic GoF structure.""
    }
  ]
}",30.824677
PMART-Azureus-PEPeerTransportFactory.java,factory,gemini-3.0-pro,Simple Factory,100,100,"The class acts as a centralized entry point for creating objects (specifically peer transports and servers). It utilizes static methods ('createTransport', 'createServer') to encapsulate the instantiation logic of concrete classes ('PEPeerTransportImpl', 'PESharedPortServerImpl') and returns them via their interfaces. This creates a decoupling between the client code and the specific implementations. The method 'createExtendedTransports' further demonstrates this by using a registry of handlers to dynamically manufacture objects based on input protocols.","```json
{
	""design_patterns"": [{
		""pattern"": ""Simple Factory"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class acts as a centralized entry point for creating objects (specifically peer transports and servers). It utilizes static methods ('createTransport', 'createServer') to encapsulate the instantiation logic of concrete classes ('PEPeerTransportImpl', 'PESharedPortServerImpl') and returns them via their interfaces. This creates a decoupling between the client code and the specific implementations. The method 'createExtendedTransports' further demonstrates this by using a registry of handlers to dynamically manufacture objects based on input protocols.""
	}]
}
```",30.21216
PMART-Azureus-SFPluginDetailsLoaderFactory.java,factory,gpt-5,Factory Method,82,88,"SFPluginDetailsLoaderFactory exposes a static method that returns an SFPluginDetailsLoader while hiding the concrete SFPluginDetailsLoaderImpl. This centralizes and encapsulates object provision behind an interface. Although it’s a static factory (not the classic overridable method from GoF), it follows the intent of a factory method by decoupling clients from the concrete type.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 82,
      ""adherence"": 88,
      ""reason"": ""SFPluginDetailsLoaderFactory exposes a static method that returns an SFPluginDetailsLoader while hiding the concrete SFPluginDetailsLoaderImpl. This centralizes and encapsulates object provision behind an interface. Although it’s a static factory (not the classic overridable method from GoF), it follows the intent of a factory method by decoupling clients from the concrete type.""
    },
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 64,
      ""adherence"": 55,
      ""reason"": ""The factory delegates to SFPluginDetailsLoaderImpl.getSingleton(), indicating the implementation likely follows the Singleton pattern. However, the singleton’s implementation details (private constructor, thread-safety, lazy vs eager init) are not shown, so adherence cannot be fully verified.""
    }
  ]
}",20.780917
PMART-Azureus-SFPluginDetailsLoaderFactory.java,factory,gpt-5,Singleton,64,55,"The factory delegates to SFPluginDetailsLoaderImpl.getSingleton(), indicating the implementation likely follows the Singleton pattern. However, the singleton’s implementation details (private constructor, thread-safety, lazy vs eager init) are not shown, so adherence cannot be fully verified.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 82,
      ""adherence"": 88,
      ""reason"": ""SFPluginDetailsLoaderFactory exposes a static method that returns an SFPluginDetailsLoader while hiding the concrete SFPluginDetailsLoaderImpl. This centralizes and encapsulates object provision behind an interface. Although it’s a static factory (not the classic overridable method from GoF), it follows the intent of a factory method by decoupling clients from the concrete type.""
    },
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 64,
      ""adherence"": 55,
      ""reason"": ""The factory delegates to SFPluginDetailsLoaderImpl.getSingleton(), indicating the implementation likely follows the Singleton pattern. However, the singleton’s implementation details (private constructor, thread-safety, lazy vs eager init) are not shown, so adherence cannot be fully verified.""
    }
  ]
}",20.780917
PMART-Azureus-SFPluginDetailsLoaderFactory.java,factory,gemini-3.0-pro,Factory,90,85,"The class implements a Static Factory method. Although it delegates the actual retrieval to another class (`SFPluginDetailsLoaderImpl`), it serves the architectural purpose of a Factory by decoupling the client from the concrete implementation. The client requests the abstract type (`SFPluginDetailsLoader`) via the factory, without needing to know that `SFPluginDetailsLoaderImpl` exists or that it is located in the `impl2` package.","```json
{
	""design_patterns"": [{
		""pattern"": ""Factory"",
		""confidence"": 90,
		""adherence"": 85,
		""reason"": ""The class implements a Static Factory method. Although it delegates the actual retrieval to another class (`SFPluginDetailsLoaderImpl`), it serves the architectural purpose of a Factory by decoupling the client from the concrete implementation. The client requests the abstract type (`SFPluginDetailsLoader`) via the factory, without needing to know that `SFPluginDetailsLoaderImpl` exists or that it is located in the `impl2` package.""
	}]
}
```",24.779374
DPD-pcgen-svn-CampaignInfoFactory.java,factory,gpt-5,Strategy,68,70,"The interface defines a contract for an algorithm (producing HTML info for a campaign) that can vary by implementation. Clients can supply different CampaignInfoFactory implementations to change the behavior without modifying client code. Despite the name 'Factory', it does not create objects/families; it returns a String and serves as an interchangeable behavior provider, aligning with Strategy rather than Factory/Abstract Factory.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 68,
      ""adherence"": 70,
      ""reason"": ""The interface defines a contract for an algorithm (producing HTML info for a campaign) that can vary by implementation. Clients can supply different CampaignInfoFactory implementations to change the behavior without modifying client code. Despite the name 'Factory', it does not create objects/families; it returns a String and serves as an interchangeable behavior provider, aligning with Strategy rather than Factory/Abstract Factory.""
    }
  ]
}",14.730103
DPD-pcgen-svn-CampaignInfoFactory.java,factory,gemini-3.0-pro,None,0,0,No pattern detected or parse error,"```json
{
	""design_patterns"": []
}
```",39.643696
DPD-dozer-BaseSampleBeanFactory.java,factory,gpt-5,None,0,0,No pattern detected or parse error,"{""design_patterns"": []}",16.48539
DPD-dozer-BaseSampleBeanFactory.java,factory,gemini-3.0-pro,None,0,0,No pattern detected or parse error,"```json
{
  ""design_patterns"": []
}
```",49.863987
DPD-jbehave-core-PicoStepsFactory.java,factory,gpt-5,Service Locator,85,90,"The class queries a PicoContainer to retrieve components by type (getComponent) and to enumerate available components (getComponentAdapters). This central registry lookup decouples clients from concrete creation and wiring, which is characteristic of the Service Locator pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The class queries a PicoContainer to retrieve components by type (getComponent) and to enumerate available components (getComponentAdapters). This central registry lookup decouples clients from concrete creation and wiring, which is characteristic of the Service Locator pattern.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 72,
      ""adherence"": 80,
      ""reason"": ""Creation of step instances is deferred to an overridable method (createInstanceOfType). The superclass defines the contract, while this subclass customizes how instances are produced (delegating to PicoContainer), which is a typical Factory Method usage.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""The subclass overrides primitive operations (stepsTypes and createInstanceOfType), suggesting the superclass (AbstractStepsFactory) defines the algorithm’s skeleton and calls these hooks to discover types and instantiate them. This aligns with Template Method, even though the template is in the unseen superclass.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 65,
      ""reason"": ""PicoStepsFactory is one interchangeable implementation of an InjectableStepsFactory, providing a specific strategy (PicoContainer-backed) for locating and instantiating steps. Clients can swap this with other factories to change behavior at runtime.""
    }
  ]
}",37.444825
DPD-jbehave-core-PicoStepsFactory.java,factory,gpt-5,Factory Method,72,80,"Creation of step instances is deferred to an overridable method (createInstanceOfType). The superclass defines the contract, while this subclass customizes how instances are produced (delegating to PicoContainer), which is a typical Factory Method usage.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The class queries a PicoContainer to retrieve components by type (getComponent) and to enumerate available components (getComponentAdapters). This central registry lookup decouples clients from concrete creation and wiring, which is characteristic of the Service Locator pattern.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 72,
      ""adherence"": 80,
      ""reason"": ""Creation of step instances is deferred to an overridable method (createInstanceOfType). The superclass defines the contract, while this subclass customizes how instances are produced (delegating to PicoContainer), which is a typical Factory Method usage.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""The subclass overrides primitive operations (stepsTypes and createInstanceOfType), suggesting the superclass (AbstractStepsFactory) defines the algorithm’s skeleton and calls these hooks to discover types and instantiate them. This aligns with Template Method, even though the template is in the unseen superclass.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 65,
      ""reason"": ""PicoStepsFactory is one interchangeable implementation of an InjectableStepsFactory, providing a specific strategy (PicoContainer-backed) for locating and instantiating steps. Clients can swap this with other factories to change behavior at runtime.""
    }
  ]
}",37.444825
DPD-jbehave-core-PicoStepsFactory.java,factory,gpt-5,Template Method,65,75,"The subclass overrides primitive operations (stepsTypes and createInstanceOfType), suggesting the superclass (AbstractStepsFactory) defines the algorithm’s skeleton and calls these hooks to discover types and instantiate them. This aligns with Template Method, even though the template is in the unseen superclass.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The class queries a PicoContainer to retrieve components by type (getComponent) and to enumerate available components (getComponentAdapters). This central registry lookup decouples clients from concrete creation and wiring, which is characteristic of the Service Locator pattern.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 72,
      ""adherence"": 80,
      ""reason"": ""Creation of step instances is deferred to an overridable method (createInstanceOfType). The superclass defines the contract, while this subclass customizes how instances are produced (delegating to PicoContainer), which is a typical Factory Method usage.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""The subclass overrides primitive operations (stepsTypes and createInstanceOfType), suggesting the superclass (AbstractStepsFactory) defines the algorithm’s skeleton and calls these hooks to discover types and instantiate them. This aligns with Template Method, even though the template is in the unseen superclass.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 65,
      ""reason"": ""PicoStepsFactory is one interchangeable implementation of an InjectableStepsFactory, providing a specific strategy (PicoContainer-backed) for locating and instantiating steps. Clients can swap this with other factories to change behavior at runtime.""
    }
  ]
}",37.444825
DPD-jbehave-core-PicoStepsFactory.java,factory,gpt-5,Strategy,55,65,"PicoStepsFactory is one interchangeable implementation of an InjectableStepsFactory, providing a specific strategy (PicoContainer-backed) for locating and instantiating steps. Clients can swap this with other factories to change behavior at runtime.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 85,
      ""adherence"": 90,
      ""reason"": ""The class queries a PicoContainer to retrieve components by type (getComponent) and to enumerate available components (getComponentAdapters). This central registry lookup decouples clients from concrete creation and wiring, which is characteristic of the Service Locator pattern.""
    },
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 72,
      ""adherence"": 80,
      ""reason"": ""Creation of step instances is deferred to an overridable method (createInstanceOfType). The superclass defines the contract, while this subclass customizes how instances are produced (delegating to PicoContainer), which is a typical Factory Method usage.""
    },
    {
      ""pattern"": ""Template Method"",
      ""confidence"": 65,
      ""adherence"": 75,
      ""reason"": ""The subclass overrides primitive operations (stepsTypes and createInstanceOfType), suggesting the superclass (AbstractStepsFactory) defines the algorithm’s skeleton and calls these hooks to discover types and instantiate them. This aligns with Template Method, even though the template is in the unseen superclass.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 55,
      ""adherence"": 65,
      ""reason"": ""PicoStepsFactory is one interchangeable implementation of an InjectableStepsFactory, providing a specific strategy (PicoContainer-backed) for locating and instantiating steps. Clients can swap this with other factories to change behavior at runtime.""
    }
  ]
}",37.444825
DPD-jbehave-core-PicoStepsFactory.java,factory,gemini-3.0-pro,Adapter,95,90,"The class acts as an Object Adapter. It holds a reference to an external component ('PicoContainer', the adaptee) and adapts it to the 'AbstractStepsFactory' interface (the target). It translates the 'createInstanceOfType' request into the container's specific 'getComponent' method, bridging the gap between JBehave's expected interface and the PicoContainer API.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Adapter"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class acts as an Object Adapter. It holds a reference to an external component ('PicoContainer', the adaptee) and adapts it to the 'AbstractStepsFactory' interface (the target). It translates the 'createInstanceOfType' request into the container's specific 'getComponent' method, bridging the gap between JBehave's expected interface and the PicoContainer API.""
		},
		{
			""pattern"": ""Factory Method"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The class extends 'AbstractStepsFactory' and overrides the 'createInstanceOfType' method. This structure delegates the logic of instantiation (or in this case, retrieval) to the subclass, allowing the parent class to define the workflow while the subclass provides the concrete implementation of how the object is obtained.""
		}
	]
}
```",26.355314
DPD-jbehave-core-PicoStepsFactory.java,factory,gemini-3.0-pro,Factory Method,90,95,"The class extends 'AbstractStepsFactory' and overrides the 'createInstanceOfType' method. This structure delegates the logic of instantiation (or in this case, retrieval) to the subclass, allowing the parent class to define the workflow while the subclass provides the concrete implementation of how the object is obtained.","```json
{
	""design_patterns"": [
		{
			""pattern"": ""Adapter"",
			""confidence"": 95,
			""adherence"": 90,
			""reason"": ""The class acts as an Object Adapter. It holds a reference to an external component ('PicoContainer', the adaptee) and adapts it to the 'AbstractStepsFactory' interface (the target). It translates the 'createInstanceOfType' request into the container's specific 'getComponent' method, bridging the gap between JBehave's expected interface and the PicoContainer API.""
		},
		{
			""pattern"": ""Factory Method"",
			""confidence"": 90,
			""adherence"": 95,
			""reason"": ""The class extends 'AbstractStepsFactory' and overrides the 'createInstanceOfType' method. This structure delegates the logic of instantiation (or in this case, retrieval) to the subclass, allowing the parent class to define the workflow while the subclass provides the concrete implementation of how the object is obtained.""
		}
	]
}
```",26.355314
DPD-dozer-JAXBBeanFactory.java,factory,gpt-5,Factory Method,90,88,"JAXBBeanFactory implements the BeanFactory interface and overrides createBean to decide how to instantiate the requested type. Clients depend on the BeanFactory interface, while this concrete factory encapsulates the instantiation logic (deriving the ObjectFactory class, choosing the createX method by name, and invoking it via reflection). This aligns with Factory Method where subclasses/implementations determine the concrete creation.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""JAXBBeanFactory implements the BeanFactory interface and overrides createBean to decide how to instantiate the requested type. Clients depend on the BeanFactory interface, while this concrete factory encapsulates the instantiation logic (deriving the ObjectFactory class, choosing the createX method by name, and invoking it via reflection). This aligns with Factory Method where subclasses/implementations determine the concrete creation.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 72,
      ""reason"": ""The class adapts Dozer's BeanFactory SPI to JAXB's generated ObjectFactory API. It takes a beanId expected by Dozer and translates it into calls to JAXB's ObjectFactory.create<SimpleName>() method, effectively bridging two incompatible interfaces without exposing JAXB details to the caller.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""BeanFactory defines a family of interchangeable object-creation behaviors, and JAXBBeanFactory is one concrete implementation that can be swapped for others. While the selection mechanism is not shown here, the use of an interface and pluggable implementation suggests the Strategy pattern for creation behavior.""
    }
  ]
}",30.0168
DPD-dozer-JAXBBeanFactory.java,factory,gpt-5,Adapter,68,72,"The class adapts Dozer's BeanFactory SPI to JAXB's generated ObjectFactory API. It takes a beanId expected by Dozer and translates it into calls to JAXB's ObjectFactory.create<SimpleName>() method, effectively bridging two incompatible interfaces without exposing JAXB details to the caller.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""JAXBBeanFactory implements the BeanFactory interface and overrides createBean to decide how to instantiate the requested type. Clients depend on the BeanFactory interface, while this concrete factory encapsulates the instantiation logic (deriving the ObjectFactory class, choosing the createX method by name, and invoking it via reflection). This aligns with Factory Method where subclasses/implementations determine the concrete creation.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 72,
      ""reason"": ""The class adapts Dozer's BeanFactory SPI to JAXB's generated ObjectFactory API. It takes a beanId expected by Dozer and translates it into calls to JAXB's ObjectFactory.create<SimpleName>() method, effectively bridging two incompatible interfaces without exposing JAXB details to the caller.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""BeanFactory defines a family of interchangeable object-creation behaviors, and JAXBBeanFactory is one concrete implementation that can be swapped for others. While the selection mechanism is not shown here, the use of an interface and pluggable implementation suggests the Strategy pattern for creation behavior.""
    }
  ]
}",30.0168
DPD-dozer-JAXBBeanFactory.java,factory,gpt-5,Strategy,60,60,"BeanFactory defines a family of interchangeable object-creation behaviors, and JAXBBeanFactory is one concrete implementation that can be swapped for others. While the selection mechanism is not shown here, the use of an interface and pluggable implementation suggests the Strategy pattern for creation behavior.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 90,
      ""adherence"": 88,
      ""reason"": ""JAXBBeanFactory implements the BeanFactory interface and overrides createBean to decide how to instantiate the requested type. Clients depend on the BeanFactory interface, while this concrete factory encapsulates the instantiation logic (deriving the ObjectFactory class, choosing the createX method by name, and invoking it via reflection). This aligns with Factory Method where subclasses/implementations determine the concrete creation.""
    },
    {
      ""pattern"": ""Adapter"",
      ""confidence"": 68,
      ""adherence"": 72,
      ""reason"": ""The class adapts Dozer's BeanFactory SPI to JAXB's generated ObjectFactory API. It takes a beanId expected by Dozer and translates it into calls to JAXB's ObjectFactory.create<SimpleName>() method, effectively bridging two incompatible interfaces without exposing JAXB details to the caller.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""BeanFactory defines a family of interchangeable object-creation behaviors, and JAXBBeanFactory is one concrete implementation that can be swapped for others. While the selection mechanism is not shown here, the use of an interface and pluggable implementation suggests the Strategy pattern for creation behavior.""
    }
  ]
}",30.0168
DPD-dozer-JAXBBeanFactory.java,factory,gemini-3.0-pro,Factory,100,100,"The class 'JAXBBeanFactory' implements the 'BeanFactory' interface and encapsulates the logic required to create instances of JAXB objects. It hides the complexity of instantiation (which involves string manipulation to handle inner classes, dynamic class loading of a delegate 'ObjectFactory', and reflection-based method invocation) from the client, strictly adhering to the Creational Factory pattern.","```json
{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory"",
      ""confidence"": 100,
      ""adherence"": 100,
      ""reason"": ""The class 'JAXBBeanFactory' implements the 'BeanFactory' interface and encapsulates the logic required to create instances of JAXB objects. It hides the complexity of instantiation (which involves string manipulation to handle inner classes, dynamic class loading of a delegate 'ObjectFactory', and reflection-based method invocation) from the client, strictly adhering to the Creational Factory pattern.""
    }
  ]
}
```",31.01208
DPD-magic-config-DecoratorFactory.java,factory,gpt-5,Factory Method,68,50,"The interface defines a creation method (createDecorator) that returns a product type (Decorator) and defers instantiation to implementors, which aligns with the Factory Method intent. However, this snippet alone lacks concrete creator implementations and concrete product classes to fully demonstrate the pattern, and the presence of a discriminator parameter (decoratorType: String) leans toward a parameterized/simple factory approach rather than letting subclasses decide purely by overriding, reducing adherence.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 68,
      ""adherence"": 50,
      ""reason"": ""The interface defines a creation method (createDecorator) that returns a product type (Decorator) and defers instantiation to implementors, which aligns with the Factory Method intent. However, this snippet alone lacks concrete creator implementations and concrete product classes to fully demonstrate the pattern, and the presence of a discriminator parameter (decoratorType: String) leans toward a parameterized/simple factory approach rather than letting subclasses decide purely by overriding, reducing adherence.""
    }
  ]
}",14.844849
DPD-magic-config-DecoratorFactory.java,factory,gemini-3.0-pro,Factory,98,100,"The code defines an interface named `DecoratorFactory` with a method `createDecorator` responsible for instantiating and returning `Decorator` objects. This structure encapsulates object creation and decouples the client from specific concrete implementations, which is the exact definition of the Factory pattern (specifically acting as the Abstract Factory or Creator interface).","```json
{
	""design_patterns"": [{
		""pattern"": ""Factory"",
		""confidence"": 98,
		""adherence"": 100,
		""reason"": ""The code defines an interface named `DecoratorFactory` with a method `createDecorator` responsible for instantiating and returning `Decorator` objects. This structure encapsulates object creation and decouples the client from specific concrete implementations, which is the exact definition of the Factory pattern (specifically acting as the Abstract Factory or Creator interface).""
	}]
}
```",29.28608
PMART-Xerces-DatatypeValidatorFactory.java,factory,gpt-5,Factory Method,87,75,"The DatatypeValidatorFactory interface declares a createDatatypeValidator method that returns a DatatypeValidator (the product). Concrete implementations are expected to decide which concrete validator to instantiate based on inputs (typeName, base, facets, list). This matches the Factory Method pattern where an abstract creator defines a factory method for creating products. Adherence is partial because only the abstract creator is shown; no concrete creators or concrete product hierarchy are present in the snippet.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 87,
      ""adherence"": 75,
      ""reason"": ""The DatatypeValidatorFactory interface declares a createDatatypeValidator method that returns a DatatypeValidator (the product). Concrete implementations are expected to decide which concrete validator to instantiate based on inputs (typeName, base, facets, list). This matches the Factory Method pattern where an abstract creator defines a factory method for creating products. Adherence is partial because only the abstract creator is shown; no concrete creators or concrete product hierarchy are present in the snippet.""
    }
  ]
}",12.348831
PMART-Xerces-DatatypeValidatorFactory.java,factory,gemini-3.0-pro,Abstract Factory,95,100,"The provided source code is an interface (`DatatypeValidatorFactory`) that defines a method (`createDatatypeValidator`) responsible for instantiating objects of a specific type (`DatatypeValidator`). This corresponds exactly to the 'AbstractFactory' participant in the Abstract Factory design pattern, which defines an interface for creating objects without specifying their concrete classes.","```json
{
	""design_patterns"": [{
		""pattern"": ""Abstract Factory"",
		""confidence"": 95,
		""adherence"": 100,
		""reason"": ""The provided source code is an interface (`DatatypeValidatorFactory`) that defines a method (`createDatatypeValidator`) responsible for instantiating objects of a specific type (`DatatypeValidator`). This corresponds exactly to the 'AbstractFactory' participant in the Abstract Factory design pattern, which defines an interface for creating objects without specifying their concrete classes.""
	}]
}
```",37.108775
DPD-SamyGo-Android-Remote-CSeriesKeyCodeSenderFactory.java,factory,gpt-5,Factory Method,85,95,"CSeriesKeyCodeSenderFactory extends SenderFactory and overrides a factory method (create) to instantiate and return a concrete product (new CSeriesSender). The creation logic is encapsulated in the subclass and depends on runtime data (host, MAC address), which aligns with the Factory Method pattern where subclasses decide which concrete product to create.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 95,
      ""reason"": ""CSeriesKeyCodeSenderFactory extends SenderFactory and overrides a factory method (create) to instantiate and return a concrete product (new CSeriesSender). The creation logic is encapsulated in the subclass and depends on runtime data (host, MAC address), which aligns with the Factory Method pattern where subclasses decide which concrete product to create.""
    }
  ]
}",11.666533
DPD-SamyGo-Android-Remote-CSeriesKeyCodeSenderFactory.java,factory,gemini-3.0-pro,Factory Method,100,100,"The class 'CSeriesKeyCodeSenderFactory' (Concrete Creator) extends 'SenderFactory' (Creator) and overrides the 'create' method. Inside this method, it encapsulates the complex logic required to instantiate a specific object, 'CSeriesSender' (Concrete Product), while returning it as the abstract type 'Sender' (Product). This allows the instantiation logic to be deferred to the subclass, which is the definition of the Factory Method pattern.","```json
{
	""design_patterns"": [{
		""pattern"": ""Factory Method"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'CSeriesKeyCodeSenderFactory' (Concrete Creator) extends 'SenderFactory' (Creator) and overrides the 'create' method. Inside this method, it encapsulates the complex logic required to instantiate a specific object, 'CSeriesSender' (Concrete Product), while returning it as the abstract type 'Sender' (Product). This allows the instantiation logic to be deferred to the subclass, which is the definition of the Factory Method pattern.""
	}]
}
```",20.99646
DPD-swing-mvc-demo-EnvironmentBindingFactory.java,factory,gpt-5,Factory Method,92,90,"The class implements the BindingFactory interface and overrides newBinding to create and return a concrete Binding (EnvironmentBinding). The object-creation logic is encapsulated, including parsing the expression and using reflection, which is characteristic of the Factory Method pattern.","{""design_patterns"": [{""pattern"": ""Factory Method"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class implements the BindingFactory interface and overrides newBinding to create and return a concrete Binding (EnvironmentBinding). The object-creation logic is encapsulated, including parsing the expression and using reflection, which is characteristic of the Factory Method pattern.""}, {""pattern"": ""Dependency Injection"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Dependencies (Environment and PropertyConduitSource) are provided via constructor injection rather than being created internally, demonstrating inversion of control and promoting decoupling and testability.""}, {""pattern"": ""Strategy"", ""confidence"": 58, ""adherence"": 60, ""reason"": ""BindingFactory serves as a pluggable interface for different algorithms to produce bindings from expressions. EnvironmentBindingFactory provides one such algorithm focused on environment-based bindings. While typical in frameworks like Tapestry, the code snippet alone only partially evidences interchangeable strategies.""}]}",46.257563
DPD-swing-mvc-demo-EnvironmentBindingFactory.java,factory,gpt-5,Dependency Injection,80,85,"Dependencies (Environment and PropertyConduitSource) are provided via constructor injection rather than being created internally, demonstrating inversion of control and promoting decoupling and testability.","{""design_patterns"": [{""pattern"": ""Factory Method"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class implements the BindingFactory interface and overrides newBinding to create and return a concrete Binding (EnvironmentBinding). The object-creation logic is encapsulated, including parsing the expression and using reflection, which is characteristic of the Factory Method pattern.""}, {""pattern"": ""Dependency Injection"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Dependencies (Environment and PropertyConduitSource) are provided via constructor injection rather than being created internally, demonstrating inversion of control and promoting decoupling and testability.""}, {""pattern"": ""Strategy"", ""confidence"": 58, ""adherence"": 60, ""reason"": ""BindingFactory serves as a pluggable interface for different algorithms to produce bindings from expressions. EnvironmentBindingFactory provides one such algorithm focused on environment-based bindings. While typical in frameworks like Tapestry, the code snippet alone only partially evidences interchangeable strategies.""}]}",46.257563
DPD-swing-mvc-demo-EnvironmentBindingFactory.java,factory,gpt-5,Strategy,58,60,"BindingFactory serves as a pluggable interface for different algorithms to produce bindings from expressions. EnvironmentBindingFactory provides one such algorithm focused on environment-based bindings. While typical in frameworks like Tapestry, the code snippet alone only partially evidences interchangeable strategies.","{""design_patterns"": [{""pattern"": ""Factory Method"", ""confidence"": 92, ""adherence"": 90, ""reason"": ""The class implements the BindingFactory interface and overrides newBinding to create and return a concrete Binding (EnvironmentBinding). The object-creation logic is encapsulated, including parsing the expression and using reflection, which is characteristic of the Factory Method pattern.""}, {""pattern"": ""Dependency Injection"", ""confidence"": 80, ""adherence"": 85, ""reason"": ""Dependencies (Environment and PropertyConduitSource) are provided via constructor injection rather than being created internally, demonstrating inversion of control and promoting decoupling and testability.""}, {""pattern"": ""Strategy"", ""confidence"": 58, ""adherence"": 60, ""reason"": ""BindingFactory serves as a pluggable interface for different algorithms to produce bindings from expressions. EnvironmentBindingFactory provides one such algorithm focused on environment-based bindings. While typical in frameworks like Tapestry, the code snippet alone only partially evidences interchangeable strategies.""}]}",46.257563
DPD-swing-mvc-demo-EnvironmentBindingFactory.java,factory,gemini-3.0-pro,Factory Method,100,100,"The class `EnvironmentBindingFactory` explicitly implements an interface `BindingFactory` which defines a contract for creating objects. The `newBinding` method encapsulates the complex logic (parsing expressions, reflection, and dependency lookups) required to instantiate and return a specific concrete product (`EnvironmentBinding`), while the return type is the interface `Binding`. This effectively decouples the client code from the specific class instantiation.","```json
{
	""design_patterns"": [{
		""pattern"": ""Factory Method"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class `EnvironmentBindingFactory` explicitly implements an interface `BindingFactory` which defines a contract for creating objects. The `newBinding` method encapsulates the complex logic (parsing expressions, reflection, and dependency lookups) required to instantiate and return a specific concrete product (`EnvironmentBinding`), while the return type is the interface `Binding`. This effectively decouples the client code from the specific class instantiation.""
	}]
}
```",15.38683
DPD-dozer-UserBeanFactory.java,factory,gpt-5,Factory Method,88,85,"UserBeanFactory implements the BeanFactory interface and overrides createBean to encapsulate object instantiation. It decides which concrete class to instantiate based on the target type (using isAssignableFrom checks) and falls back to reflective instantiation (Class.forName + newInstance). This aligns with Factory Method: the framework calls a factory interface, and the concrete factory determines the product class. It is not Abstract Factory (no family of products with multiple creation methods), nor Service Locator (no registry), nor Observer.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 85,
      ""reason"": ""UserBeanFactory implements the BeanFactory interface and overrides createBean to encapsulate object instantiation. It decides which concrete class to instantiate based on the target type (using isAssignableFrom checks) and falls back to reflective instantiation (Class.forName + newInstance). This aligns with Factory Method: the framework calls a factory interface, and the concrete factory determines the product class. It is not Abstract Factory (no family of products with multiple creation methods), nor Service Locator (no registry), nor Observer.""
    }
  ]
}",23.785585
DPD-dozer-UserBeanFactory.java,factory,gemini-3.0-pro,Factory Method,100,100,"The class 'UserBeanFactory' implements an interface 'BeanFactory' and defines a method 'createBean' responsible for object creation. It encapsulates the instantiation logic by determining which concrete class (e.g., 'UserImpl', 'UserGroupImpl') to create based on the input parameters (target bean ID or class type). This decouples the client code from the specific concrete classes being instantiated.","```json
{
	""design_patterns"": [{
		""pattern"": ""Factory Method"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'UserBeanFactory' implements an interface 'BeanFactory' and defines a method 'createBean' responsible for object creation. It encapsulates the instantiation logic by determining which concrete class (e.g., 'UserImpl', 'UserGroupImpl') to create based on the input parameters (target bean ID or class type). This decouples the client code from the specific concrete classes being instantiated.""
	}]
}
```",28.968655
DPD-orion.server-ResourceShapeFactory.java,factory,gpt-5,Factory Method,72,58,"ResourceShapeFactory centralizes creation/selection of ResourceShape via the static createResourceShape method, encapsulating decision logic (default vs. query-based) and hiding reflection details (getResourceShape, getDefaultResourceShape). However, it does not use subclassing or overrideable factory methods; instead it is a static/simple factory that retrieves existing instances from fields via reflection, so it only loosely adheres to the classic GoF Factory Method.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 72,
      ""adherence"": 58,
      ""reason"": ""ResourceShapeFactory centralizes creation/selection of ResourceShape via the static createResourceShape method, encapsulating decision logic (default vs. query-based) and hiding reflection details (getResourceShape, getDefaultResourceShape). However, it does not use subclassing or overrideable factory methods; instead it is a static/simple factory that retrieves existing instances from fields via reflection, so it only loosely adheres to the classic GoF Factory Method.""
    }
  ]
}",51.316859
DPD-orion.server-ResourceShapeFactory.java,factory,gemini-3.0-pro,Simple Factory,95,90,"The class contains a static method `createResourceShape` that encapsulates the logic for instantiating or retrieving a `ResourceShape` object based on input parameters (the resource class and selection query). It hides the complexity of parsing the query, checking annotations, and using reflection to find the specific field, which is the primary definition of the Simple Factory idiom (also known as a Static Factory Method).","```json
{
	""design_patterns"": [{
		""pattern"": ""Simple Factory"",
		""confidence"": 95,
		""adherence"": 90,
		""reason"": ""The class contains a static method `createResourceShape` that encapsulates the logic for instantiating or retrieving a `ResourceShape` object based on input parameters (the resource class and selection query). It hides the complexity of parsing the query, checking annotations, and using reflection to find the specific field, which is the primary definition of the Simple Factory idiom (also known as a Static Factory Method).""
	}]
}
```",20.344027
PMART-Azureus-DHTDBFactory.java,factory,gpt-5,Factory Method,90,70,"DHTDBFactory provides a static create method that returns the interface type (DHTDB) while instantiating a concrete implementation (DHTDBImpl), encapsulating object creation and decoupling clients from the implementation. This is a static/simple factory variant rather than the classic overridable factory method, hence partial adherence.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 90,
      ""adherence"": 70,
      ""reason"": ""DHTDBFactory provides a static create method that returns the interface type (DHTDB) while instantiating a concrete implementation (DHTDBImpl), encapsulating object creation and decoupling clients from the implementation. This is a static/simple factory variant rather than the classic overridable factory method, hence partial adherence.""
    }
  ]
}",16.607193
PMART-Azureus-DHTDBFactory.java,factory,gemini-3.0-pro,Simple Factory,100,100,"The class 'DHTDBFactory' contains a static method 'create' that encapsulates the instantiation logic of the 'DHTDB' object. It returns a concrete instance ('DHTDBImpl') masked by an interface or abstract type ('DHTDB'), thereby decoupling the client code from the specific implementation details.","```json
{
	""design_patterns"": [{
		""pattern"": ""Simple Factory"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'DHTDBFactory' contains a static method 'create' that encapsulates the instantiation logic of the 'DHTDB' object. It returns a concrete instance ('DHTDBImpl') masked by an interface or abstract type ('DHTDB'), thereby decoupling the client code from the specific implementation details.""
	}]
}
```",17.458161
PMART-Azureus-DiskAccessControllerFactory.java,factory,gpt-5,Factory Method,88,60,"DiskAccessControllerFactory exposes a static create method that returns the interface type DiskAccessController while instantiating the concrete DiskAccessControllerImpl, hiding construction details from clients. However, the creation logic is hard-coded and not polymorphically overridden (no subclass-based variation of the factory), making it a simple/static factory rather than the full GoF factory method.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 88,
      ""adherence"": 60,
      ""reason"": ""DiskAccessControllerFactory exposes a static create method that returns the interface type DiskAccessController while instantiating the concrete DiskAccessControllerImpl, hiding construction details from clients. However, the creation logic is hard-coded and not polymorphically overridden (no subclass-based variation of the factory), making it a simple/static factory rather than the full GoF factory method.""
    }
  ]
}",20.509911
PMART-Azureus-DiskAccessControllerFactory.java,factory,gemini-3.0-pro,Simple Factory,100,100,"The class functions as a Simple Factory (also known as a Static Factory Method). It provides a public static method ('create') that encapsulates the logic for instantiating an object. It hides the concrete implementation ('DiskAccessControllerImpl') from the caller, returning the object via its interface or abstract type ('DiskAccessController'). This decouples the client code from the specific implementation class.","```json
{
	""design_patterns"": [{
		""pattern"": ""Simple Factory"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class functions as a Simple Factory (also known as a Static Factory Method). It provides a public static method ('create') that encapsulates the logic for instantiating an object. It hides the concrete implementation ('DiskAccessControllerImpl') from the caller, returning the object via its interface or abstract type ('DiskAccessController'). This decouples the client code from the specific implementation class.""
	}]
}
```",16.662423
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gpt-5,Factory Method,85,85,"The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.""
    },
    {
      ""pattern"": ""Flyweight"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.""
    }
  ]
}",52.456256
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gpt-5,Abstract Factory,70,65,"XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.""
    },
    {
      ""pattern"": ""Flyweight"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.""
    }
  ]
}",52.456256
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gpt-5,Flyweight,60,60,"Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.""
    },
    {
      ""pattern"": ""Flyweight"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.""
    }
  ]
}",52.456256
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gpt-5,Strategy,65,70,"Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.""
    },
    {
      ""pattern"": ""Flyweight"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.""
    }
  ]
}",52.456256
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gpt-5,Decorator,55,55,"ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 85,
      ""reason"": ""The method getBuiltInDV(String) selects and returns a DatatypeValidator based on a key (name), with this subclass extending the set of products (XML 1.1 types) and deferring to the base collection for others. Although instances are created in a static block and cached, the method still acts as the factory point for clients, consistent with Factory Method.""
    },
    {
      ""pattern"": ""Abstract Factory"",
      ""confidence"": 70,
      ""adherence"": 65,
      ""reason"": ""XML11DTDDVFactoryImpl is a concrete factory variant that extends DTDDVFactoryImpl to provide a family of related products (DTD DatatypeValidators for XML 1.1). The getBuiltInTypes() method returns the whole family by merging XML 1.1 and base types. While the abstract interface is not shown here, the inheritance-based specialization aligns with Abstract Factory.""
    },
    {
      ""pattern"": ""Flyweight"",
      ""confidence"": 60,
      ""adherence"": 60,
      ""reason"": ""Validator instances are created once and stored in static Hashtables (fXML11BuiltInTypes and inherited fBuiltInTypes) and then shared by all callers. This reuse of single instances per key matches Flyweight/Multi-ton characteristics, though explicit handling of extrinsic state is not visible.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 65,
      ""adherence"": 70,
      ""reason"": ""Clients receive DatatypeValidator (a common interface) while the factory chooses among different concrete validators (e.g., XML11IDDatatypeValidator, XML11NMTOKENDatatypeValidator). This enables interchangeable validation algorithms behind a uniform type, consistent with Strategy.""
    },
    {
      ""pattern"": ""Decorator"",
      ""confidence"": 55,
      ""adherence"": 55,
      ""reason"": ""ListDatatypeValidator is constructed with another DatatypeValidator and likely implements the same interface to add list-handling behavior around the wrapped validator. Although its implementation is not shown, the composition and type suggest a Decorator-like extension.""
    }
  ]
}",52.456256
PMART-Xerces-XML11DTDDVFactoryImpl.java,factory,gemini-3.0-pro,Abstract Factory,95,90,"The class is explicitly named and structured as a factory implementation (`XML11DTDDVFactoryImpl` extending `DTDDVFactoryImpl`). It encapsulates the creation and mapping of a specific family of related objects (XML 1.1 Datatype Validators such as `XML11IDDatatypeValidator`) behind a common interface (`DatatypeValidator`). The method `getBuiltInDV` acts as the factory method, decoupling the client from the concrete classes.","```json
{
	""design_patterns"": [{
		""pattern"": ""Abstract Factory"",
		""confidence"": 95,
		""adherence"": 90,
		""reason"": ""The class is explicitly named and structured as a factory implementation (`XML11DTDDVFactoryImpl` extending `DTDDVFactoryImpl`). It encapsulates the creation and mapping of a specific family of related objects (XML 1.1 Datatype Validators such as `XML11IDDatatypeValidator`) behind a common interface (`DatatypeValidator`). The method `getBuiltInDV` acts as the factory method, decoupling the client from the concrete classes.""
	}]
}
```",39.285464
PMART-Azureus-ExternalIPCheckerFactory.java,factory,gpt-5,Factory Method,85,55,"ExternalIPCheckerFactory exposes a static create() that returns the interface type (ExternalIPChecker) while instantiating a concrete implementation (ExternalIPCheckerImpl), encapsulating creation and hiding the implementation. However, there is no subclassing/overridable creator and only a single product is produced, making it a simple/static factory rather than the full GoF Factory Method.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Factory Method"",
      ""confidence"": 85,
      ""adherence"": 55,
      ""reason"": ""ExternalIPCheckerFactory exposes a static create() that returns the interface type (ExternalIPChecker) while instantiating a concrete implementation (ExternalIPCheckerImpl), encapsulating creation and hiding the implementation. However, there is no subclassing/overridable creator and only a single product is produced, making it a simple/static factory rather than the full GoF Factory Method.""
    }
  ]
}",12.629473
PMART-Azureus-ExternalIPCheckerFactory.java,factory,gemini-3.0-pro,Simple Factory,100,100,"The class 'ExternalIPCheckerFactory' implements a static method 'create()' that encapsulates the instantiation logic of the concrete class 'ExternalIPCheckerImpl'. It returns the instance typed as the interface 'ExternalIPChecker'. This completely decouples the client code from the concrete implementation and centralizes the object creation, which is the exact definition of the Simple Factory idiom.","```json
{
	""design_patterns"": [{
		""pattern"": ""Simple Factory"",
		""confidence"": 100,
		""adherence"": 100,
		""reason"": ""The class 'ExternalIPCheckerFactory' implements a static method 'create()' that encapsulates the instantiation logic of the concrete class 'ExternalIPCheckerImpl'. It returns the instance typed as the interface 'ExternalIPChecker'. This completely decouples the client code from the concrete implementation and centralizes the object creation, which is the exact definition of the Simple Factory idiom.""
	}]
}
```",18.124958
PMART-PMARt-PrerequisiteTestFactory.java,factory,gpt-5,Singleton,95,75,"A single globally accessible instance via getInstance(), private constructor, and static instance field. However, lazy initialization is not thread-safe, so adherence is not perfect.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 75,
      ""reason"": ""A single globally accessible instance via getInstance(), private constructor, and static instance field. However, lazy initialization is not thread-safe, so adherence is not perfect.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 75,
      ""adherence"": 85,
      ""reason"": ""Acts as a registry mapping string keys to pre-registered PrerequisiteTest instances and returning them on demand. It centralizes lookup rather than creation, which aligns with a service locator/registry pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 65,
      ""reason"": ""PrerequisiteTest appears to define a common interface, and different concrete tests (e.g., PreAlign, PreFeat) are selected at runtime based on a key. While usage context is not shown, the structure suggests interchangeable algorithms chosen via the locator.""
    }
  ]
}",31.332318
PMART-PMARt-PrerequisiteTestFactory.java,factory,gpt-5,Service Locator,75,85,"Acts as a registry mapping string keys to pre-registered PrerequisiteTest instances and returning them on demand. It centralizes lookup rather than creation, which aligns with a service locator/registry pattern.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 75,
      ""reason"": ""A single globally accessible instance via getInstance(), private constructor, and static instance field. However, lazy initialization is not thread-safe, so adherence is not perfect.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 75,
      ""adherence"": 85,
      ""reason"": ""Acts as a registry mapping string keys to pre-registered PrerequisiteTest instances and returning them on demand. It centralizes lookup rather than creation, which aligns with a service locator/registry pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 65,
      ""reason"": ""PrerequisiteTest appears to define a common interface, and different concrete tests (e.g., PreAlign, PreFeat) are selected at runtime based on a key. While usage context is not shown, the structure suggests interchangeable algorithms chosen via the locator.""
    }
  ]
}",31.332318
PMART-PMARt-PrerequisiteTestFactory.java,factory,gpt-5,Strategy,60,65,"PrerequisiteTest appears to define a common interface, and different concrete tests (e.g., PreAlign, PreFeat) are selected at runtime based on a key. While usage context is not shown, the structure suggests interchangeable algorithms chosen via the locator.","{
  ""design_patterns"": [
    {
      ""pattern"": ""Singleton"",
      ""confidence"": 95,
      ""adherence"": 75,
      ""reason"": ""A single globally accessible instance via getInstance(), private constructor, and static instance field. However, lazy initialization is not thread-safe, so adherence is not perfect.""
    },
    {
      ""pattern"": ""Service Locator"",
      ""confidence"": 75,
      ""adherence"": 85,
      ""reason"": ""Acts as a registry mapping string keys to pre-registered PrerequisiteTest instances and returning them on demand. It centralizes lookup rather than creation, which aligns with a service locator/registry pattern.""
    },
    {
      ""pattern"": ""Strategy"",
      ""confidence"": 60,
      ""adherence"": 65,
      ""reason"": ""PrerequisiteTest appears to define a common interface, and different concrete tests (e.g., PreAlign, PreFeat) are selected at runtime based on a key. While usage context is not shown, the structure suggests interchangeable algorithms chosen via the locator.""
    }
  ]
}",31.332318
PMART-PMARt-PrerequisiteTestFactory.java,factory,gemini-3.0-pro,Singleton,100,85,"The class explicitly implements the Singleton pattern. It features a private static 'instance' variable, a private constructor to prevent external instantiation, and a public static 'getInstance()' method to provide global access. The adherence is not 100% because the 'getInstance()' method lacks thread-safety (synchronization or double-checked locking), which could cause issues in a multi-threaded environment.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 85,
			""reason"": ""The class explicitly implements the Singleton pattern. It features a private static 'instance' variable, a private constructor to prevent external instantiation, and a public static 'getInstance()' method to provide global access. The adherence is not 100% because the 'getInstance()' method lacks thread-safety (synchronization or double-checked locking), which could cause issues in a multi-threaded environment.""
		},
		{
			""pattern"": ""Simple Factory"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class acts as a factory for 'PrerequisiteTest' objects. The 'getTest(String kind)' method abstracts the logic of retrieving a specific implementation based on a string identifier. Instead of a switch statement, it uses a registration/lookup map ('testLookup') populated in the constructor to return the correct concrete object.""
		}
	]
}
```",31.846017
PMART-PMARt-PrerequisiteTestFactory.java,factory,gemini-3.0-pro,Simple Factory,95,100,"The class acts as a factory for 'PrerequisiteTest' objects. The 'getTest(String kind)' method abstracts the logic of retrieving a specific implementation based on a string identifier. Instead of a switch statement, it uses a registration/lookup map ('testLookup') populated in the constructor to return the correct concrete object.","```json
{
	""design_patterns"": [{
			""pattern"": ""Singleton"",
			""confidence"": 100,
			""adherence"": 85,
			""reason"": ""The class explicitly implements the Singleton pattern. It features a private static 'instance' variable, a private constructor to prevent external instantiation, and a public static 'getInstance()' method to provide global access. The adherence is not 100% because the 'getInstance()' method lacks thread-safety (synchronization or double-checked locking), which could cause issues in a multi-threaded environment.""
		},
		{
			""pattern"": ""Simple Factory"",
			""confidence"": 95,
			""adherence"": 100,
			""reason"": ""The class acts as a factory for 'PrerequisiteTest' objects. The 'getTest(String kind)' method abstracts the logic of retrieving a specific implementation based on a string identifier. Instead of a switch statement, it uses a registration/lookup map ('testLookup') populated in the constructor to return the correct concrete object.""
		}
	]
}
```",31.846017
